---
title: "PPT Analysis"
description: "Summarize functional vs. imperative symbol tables, extract and annotate all related code from Compile.pptx, and explain the homework in HW.PDF."
mode: wide
---

<Card>
<div className="tools-container">
<div className="mcp-servers-container">
<div className="mcp-servers-title">
MCP Servers
</div>
<div className="mcp-servers-grid">
<div className="mcp-server-item">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="20" height="20" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg>
<span className="mcp-server-name">pptx</span>
</div>
<div className="mcp-server-item">
<svg width="20px" height="20px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg>
<span className="mcp-server-name">pdf-tools</span>
</div>
<div className="mcp-server-item">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48" width="20px" height="20px" style={{margin: 0, padding: 0, display: 'inline-block'}}><path fill="#FFA000" d="M40,12H22l-4-4H8c-2.2,0-4,1.8-4,4v8h40v-4C44,13.8,42.2,12,40,12z"/><path fill="#FFCA28" d="M40,12H8c-2.2,0-4,1.8-4,4v20c0,2.2,1.8,4,4,4h32c2.2,0,4-1.8,4-4V16C44,13.8,42.2,12,40,12z"/></svg>
<span className="mcp-server-name">filesystem</span>
</div>
</div>
</div>
<div className="local-tools-container">
<div className="mcp-servers-title">
Local Tools
</div>
<div className="local-tools-grid">
<div className="local-tool-item">
<svg width="20px" height="20px" viewBox="0 0 100 100" enable-background="new 0 0 100 100" id="Layer_1" version="1.1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style={{margin: 0, padding: 0, display: 'inline-block'}}><g><g><rect clip-rule="evenodd" fill="#F2F2F2" fill-rule="evenodd" height="83.437" width="67.025" x="9.012" y="7.604"/><path d="M77.454,92.458H7.595V6.187h69.859V92.458z M10.429,89.624H74.62V9.021H10.429V89.624z"/></g><g><rect clip-rule="evenodd" fill="#FF7C24" fill-rule="evenodd" height="10.481" width="17.952" x="46.695" y="34.866"/></g><g><rect height="2.834" width="19.463" x="20.504" y="35.575"/></g><g><rect height="2.834" width="15.561" x="20.718" y="42.508"/></g><g><rect height="2.833" width="15.562" x="20.813" y="49.514"/></g><g><rect height="2.833" width="27.128" x="20.718" y="56.753"/></g><g><rect height="2.833" width="23.51" x="20.718" y="63.688"/></g><g><rect clip-rule="evenodd" fill="#39B6CC" fill-rule="evenodd" height="9.004" width="44.095" x="20.553" y="19.064"/></g><g><rect height="2.833" width="26.272" x="20.718" y="70.32"/></g><g><rect height="2.834" width="32.8" x="20.718" y="77.253"/></g><g><rect height="2.834" width="3.235" x="38.304" y="42.508"/></g><g><path clip-rule="evenodd" d="M77.931,71.902l4.287,4.427l-6.644,6.437l-4.309-4.457    C74.147,76.998,76.504,74.726,77.931,71.902L77.931,71.902z" fill="#F2F2F2" fill-rule="evenodd"/><path d="M75.542,84.77l-6.692-6.92l1.828-0.831c2.579-1.174,4.706-3.218,5.989-5.756l0.897-1.776l6.656,6.874L75.542,84.77z     M73.584,78.669l2.023,2.091l4.605-4.463l-2.007-2.074C76.994,76.012,75.414,77.531,73.584,78.669z"/></g><g><polygon clip-rule="evenodd" fill="#39B6CC" fill-rule="evenodd" points="83.267,75.319 91.984,84.338 83.247,92.779     74.535,83.761   "/><path d="M83.213,94.783L72.531,83.726l10.771-10.41l10.687,11.056L83.213,94.783z M76.538,83.794l6.744,6.981l6.698-6.472    l-6.748-6.981L76.538,83.794z"/></g><g><path clip-rule="evenodd" d="M66.124,50.799c7.742,0,14.018,6.276,14.018,14.019    s-6.275,14.019-14.018,14.019c-7.743,0-14.019-6.276-14.019-14.019S58.381,50.799,66.124,50.799L66.124,50.799z" fill="#F2F2F2" fill-rule="evenodd"/><path d="M66.124,80.253c-8.511,0-15.435-6.924-15.435-15.435s6.924-15.435,15.435-15.435S81.56,56.307,81.56,64.818    S74.635,80.253,66.124,80.253z M66.124,52.216c-6.949,0-12.601,5.653-12.601,12.602s5.651,12.601,12.601,12.601    c6.948,0,12.602-5.652,12.602-12.601S73.072,52.216,66.124,52.216z"/></g><g><rect height="2.833" width="10.313" x="39.902" y="49.514"/></g><g><path d="M76.404,65.586H73.57c0-0.636-0.068-1.255-0.205-1.84c-0.043-0.186-0.096-0.385-0.169-0.63l2.717-0.808    c0.091,0.304,0.158,0.559,0.215,0.801C76.31,63.901,76.404,64.735,76.404,65.586z M72.438,61.433    c-1.489-2.5-4.203-4.058-7.084-4.061l0.004-2.834c3.871,0.005,7.518,2.091,9.516,5.445L72.438,61.433z"/></g></g></svg>
<span className="local-tool-name">history</span>
</div>
<div className="local-tool-item">
<svg width="20px" height="20px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M861.588238 240.133873v-65.792823c0-36.191275-29.439775-65.631049-65.631049-65.63105h-21.877358c-36.191275 0-65.631049 29.439775-65.631049 65.63105v65.631049H314.659414v-65.631049c0-36.191275-29.439775-65.631049-65.631049-65.63105h-21.877358c-36.191275 0-65.631049 29.439775-65.631049 65.63105v65.792823c-36.317212 0.868255-65.631049 30.539428-65.63105 67.061417v543.745565c0 37.06772 30.155471 67.223191 67.223191 67.223191h696.886045c37.06772 0 67.223191-30.155471 67.223191-67.223191V307.19529c-0.001024-36.52199-29.315885-66.193162-65.633097-67.061417z m-109.385765-65.792823c0-12.060345 9.817012-21.877358 21.877358-21.877358h21.877358c12.060345 0 21.877358 9.817012 21.877358 21.877358v175.016814c0 12.060345-9.817012 21.877358-21.877358 21.877358h-21.877358c-12.060345 0-21.877358-9.817012-21.877358-21.877358V174.34105z m-546.928824 0c0-12.060345 9.817012-21.877358 21.877358-21.877358h21.877358c12.060345 0 21.877358 9.817012 21.877358 21.877358v175.016814c0 12.060345-9.817012 21.877358-21.877358 21.877358h-21.877358c-12.060345 0-21.877358-9.817012-21.877358-21.877358V174.34105z m678.191947 676.600829c0 12.935767-10.532708 23.468476-23.468476 23.468475H163.111076c-12.935767 0-23.468476-10.532708-23.468476-23.468475V307.19529c0-12.402323 9.677764-22.593054 21.877358-23.415233v65.577807c0 36.191275 29.439775 65.631049 65.631049 65.631049h21.877358c36.191275 0 65.631049-29.439775 65.631049-65.631049v-65.631049h393.789368v65.631049c0 36.191275 29.439775 65.631049 65.631049 65.631049h21.877358c36.191275 0 65.631049-29.439775 65.631049-65.631049v-65.577807c12.19857 0.82218 21.877358 11.012911 21.877358 23.415233v543.746589z" fill="#22C67F" /><path d="M706.719439 478.272194l-48.01715-44.741741-182.28128 195.621482-111.468348-122.615387-48.563905 44.148911 159.469116 172.685427z" fill="#74E8AE" /></svg>
<span className="local-tool-name">claim_done</span>
</div>
<div className="local-tool-item">
<Icon icon="bars-progress" size={20} color="#4286f6" />
<span className="local-tool-name">manage_context</span>
</div>
<div className="local-tool-item">
<Icon icon="filter-list" size={20} color="#4286f6" />
<span className="local-tool-name">handle_overlong_tool_outputs</span>
</div>
</div>
</div>
</div>
</Card>







## Instruction

I'm a third-year computer science student. I was absent from the last Compiler Principles course due to illness. I'd appreciate your assistance in studying the presentation `Compile.pptx`. I need to create a note (create a new file `NOTE.md`) to help me summarize the key points of the lecture. First, please summarize the definitions of functional and imperative symbol tables and their differences in insertion operations. Then, I see a lot of code in the presentation that represents the different modes of operation for each symbol table. Please help me put all of the origin code into my notes and provide explanations for each. Finally, please explain the homework assignments `HW.PDF` for this class.



## Initial State

### Local Workspace

<div className="file-tree">
<a href="https://github.com/hkust-nlp/mcpbench_dev/tree/finalpool_dev/tasks/finalpool/ppt-analysis/initial_workspace">workspace</a>/
â”œâ”€â”€ Compile.pptx
â””â”€â”€ HW.pdf
</div>


## Model Trajectory

<AccordionGroup>
<Accordion title="claude-4.5-sonnet">

<Columns cols={3}>
<Card title="Task Completion" icon="check">
Completed
</Card>
<Card title="Tool Calls" icon="wrench">
6
</Card>
<Card title="Turns" icon="arrows-rotate">
7
</Card>
</Columns>

<div className="thinking-box">
ğŸ§`Agent`

I'll help you study the presentation and create comprehensive notes. Let me start by examining the files.
</div>

<div className="result-box">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48" width="14px" height="14px" style={{margin: 0, padding: 0, display: 'inline-block'}}><path fill="#FFA000" d="M40,12H22l-4-4H8c-2.2,0-4,1.8-4,4v8h40v-4C44,13.8,42.2,12,40,12z"/><path fill="#FFCA28" d="M40,12H8c-2.2,0-4,1.8-4,4v20c0,2.2,1.8,4,4,4h32c2.2,0,4-1.8,4-4V16C44,13.8,42.2,12,40,12z"/></svg> `filesystem list_directory`

<Expandable title="Details">
```json arguments
{
	"path": "/workspace/dumps/workspace"
}

```

```json output_result
[DIR] .pdf_tools_tempfiles
[FILE] Compile.pptx
[FILE] HW.pdf
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Now let me open and examine the presentation:
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx open_presentation`

<Expandable title="Details">
```json arguments
{
	"file_path": "/workspace/dumps/workspace/Compile.pptx"
}

```

```json output_result
{
  "presentation_id": "presentation_1",
  "message": "Opened presentation from /workspace/dumps/workspace/Compile.pptx with ID: presentation_1",
  "slide_count": 26
}
```

</Expandable>
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx extract_presentation_text`

<Expandable title="Details">
```json arguments
{
	"presentation_id": "presentation_1"
}

```

```json output_result
{
  "success": true,
  "presentation_id": "presentation_1",
  "total_slides": 26,
  "slides_with_text": 26,
  "total_text_shapes": 45,
  "slides_with_titles": 26,
  "slides_with_tables": 2,
  "slides_text": [
    {
      "slide_index": 0,
      "text_content": {
        "slide_title": "Semantic Analysis\u000bChapter 5",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis\u000bChapter 5",
            "placeholder_type": "CENTER_TITLE (3)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5"
      },
      "layout_name": "æ ‡é¢˜å¹»ç¯ç‰‡",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 1,
      "text_content": {
        "slide_title": "Semantic Analysis",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 2,
      "text_content": {
        "slide_title": "Outline",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Outline",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables\nBindings for the Tiger Compiler\nType Checking",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Outline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 3,
      "text_content": {
        "slide_title": "5.1 Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "5.1 Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 4,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "ï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 5,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Each local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 6,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 7,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 8,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 9,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Imperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 10,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 11,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 12,
      "text_content": {
        "slide_title": "Effective Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Effective Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Consider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Effective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 13,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 14,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 15,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 16,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Table",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Table",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "We can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          },
          {
            "shape_index": 5,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "bat",
                  "1"
                ]
              }
            ]
          },
          {
            "shape_index": 6,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "camel",
                  "2"
                ]
              }
            ]
          },
          {
            "shape_index": 9,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          },
          {
            "shape_index": 11,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 17,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 18,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 19,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 20,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 21,
      "text_content": {
        "slide_title": "The Implementation of Symbols",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbols",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 22,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 23,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "For destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 24,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "How can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 25,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    }
  ],
  "all_presentation_text_combined": "=== SLIDE 1 ===\nSemantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5\n\n=== SLIDE 2 ===\nSemantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code\n\n=== SLIDE 3 ===\nOutline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking\n\n=== SLIDE 4 ===\n5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?\n\n=== SLIDE 5 ===\nSymbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}\n\n=== SLIDE 6 ===\nSymbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1\n\n=== SLIDE 7 ===\nSymbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack\n\n=== SLIDE 8 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}.\n\n=== SLIDE 9 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table.\n\n=== SLIDE 10 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>\n\n=== SLIDE 11 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 12 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 13 ===\nEffective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>\n\n=== SLIDE 14 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?\n\n=== SLIDE 15 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX\n\n=== SLIDE 16 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large\n\n=== SLIDE 17 ===\nEfficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2\n\n=== SLIDE 18 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 19 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 20 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)\n\n=== SLIDE 21 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);\n\n=== SLIDE 22 ===\nThe Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}\n\n=== SLIDE 23 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}\n\n=== SLIDE 24 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}\n\n=== SLIDE 25 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.\n\n=== SLIDE 26 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}\n"
}
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Now let me examine the homework PDF:
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools get_pdf_info`

<Expandable title="Details">
```json arguments
{
	"pdf_file_path": "/workspace/dumps/workspace/HW.pdf"
}

```

```json output_result
PDF file information:
Total pages: 2
Title: 
Author: 
Creator: Typora
Creation date: 20250707010226

```

</Expandable>
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
{
	"pdf_file_path": "/workspace/dumps/workspace/HW.pdf",
	 "start_page": 1,
	 "end_page": 2
}

```

```json output_result
PDF total pages: 2
Extracted page range: 1-2

=== Page 1 ===
Compiler Principles Assignment: Semantic Analysis & Symbol Tables  
Â 
Instructions:  Based on Chapter 5 of the "Modern Compiler Implementation" presentation, please answer the  
following questions. All questions are multiple-choice or fill-in-the-blank with a single correct answer.
Question 1 (Multiple Choice)
During the semantic analysis phase, the Symbol Table is crucial. When the compiler exits a scope (e.g., after a  
function body or a let block), it must restore the symbol table to its state before entering that scope. Which  
of the following implementation methods accomplishes this "restore" operation where the primary overhead  
involves manipulating a few pointers, rather than performing a large-scale copy of the entire data structure?
A) Making a complete, deep copy of the hash-table-based symbol table upon entering the scope.
B) Using a functional-style balanced binary search tree, which only creates new nodes along the path from the  
root to the insertion point when adding a new binding.
C) Using an imperative-style hash table combined with a separate "undo stack" to log all modifications, which  
are then reversed upon exiting the scope.
D) Both B and C are correct.
Question 2 (Fill in the Blank)
In the Tiger pseudocode below, assume the initial symbol table is Ïƒ0 = {g â†¦  string, a â†¦  int}. What is the  
type bound to the variable a when the print(a) statement on line 8 is executed?
Answer:  ____
Question 3 (Multiple Choice)
When implementing an imperative-style symbol table using a hash table with external chaining to resolve  
collisions, what is the most efficient and scope-compliant way to handle the insertion of a new binding a â†¦ 
Ï„2 when an older binding a â†¦ Ï„1 for the same identifier a already exists within the table?1 function f(a:int, b:int, c:int) =
2 (
3 Â  print_int(a+c);
4 Â  let 
5 Â  Â  var j := a+b
6 Â  Â  var a := "hello"
7 Â  in 
8 Â  Â  print(a); 
9 Â  Â  print_int(j)
10  end;
11  print_int(b)
12 )1
2
3
4
5
6
7
8
9
10
11
12


=== Page 2 ===
A) Traverse the collision chain to find and overwrite the old binding a â†¦  Ï„ 1.
B) Append the new binding a â†¦  Ï„ 2 to the end of the collision chain.
C) Insert the new binding a â†¦  Ï„ 2 at the head of the collision chain, effectively shadowing the old binding.
D) Throw a "variable redefined" compilation error.
Question 4 (Fill in the Blank)
To improve the efficiency of symbol table operations, particularly the cost of string lookups and comparisons,  
the Tiger compiler employs an optimization. It converts string identifiers into a unique, fixed-size data type. All  
subsequent hash calculations and equality checks are performed on this new type, avoiding repeated,  
character-by-character operations on the original strings. This optimized data type is referred to in the  
presentation as a ____.
Answer:  ____
Question 5 (Multiple Choice)
When processing a language like Java that allows forward references, a member of one class can reference a  
member of another class that is defined later in the source code. How is this typically handled by the symbol  
table system to ensure all symbols are visible when needed?
A) A single, global symbol table is used, and all members from all classes are placed directly into it.
B) Each class (E, N, D) has its own symbol table, which are then combined (e.g., Ïƒ 2 + Ïƒ 4 + Ïƒ 6) into a single,  
comprehensive environment Ïƒ 7 representing the entire package. This combined environment is then used for  
compiling the classes within it.
C) The compiler processes declarations in strict sequential order, so when compiling D, it can only see symbols  
from E and N if they have already been fully analyzed.
D) A stack-based symbol table is used, pushing a class's table onto the stack when entering it and popping it off  
when exiting.
Â 
Â // package M;
class E { static int a = 5; }
class N { static int b = 10; static int a = E.a + b; }
class D { static int d = E.a + N.a; }1
2
3
4

```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Perfect! Now I have all the information needed. Let me create comprehensive notes for you:
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
workspace/NOTE.md
# Compiler Principles - Semantic Analysis & Symbol Tables
## Lecture Notes from Chapter 5

---

## 1. Overview of Semantic Analysis

The semantic analysis phase of a compiler performs three main tasks:
1. **Connects variable definitions to their uses**
2. **Checks that each expression has a correct type**
3. **Translates the abstract syntax into a simpler representation suitable for generating machine code**

Symbol tables (also called environments) are the core data structure used during semantic analysis, mapping identifiers to their types and locations.

---

## 2. Symbol Tables: Functional vs Imperative Styles

### 2.1 Definitions

#### **Functional Style Symbol Table**
- **Definition**: A functional symbol table maintains immutability - when creating a new environment Ïƒâ€² = Ïƒ + {a â†¦ Ï„}, the original table Ïƒ remains unchanged and available for lookup.
- **Key Characteristic**: Keep existing tables in pristine condition while creating new ones
- **Restoration**: Easy to restore previous environments since they were never modified

#### **Imperative Style Symbol Table**
- **Definition**: An imperative symbol table uses destructive updates - it modifies the existing table Ïƒ to create Ïƒâ€², making the original Ïƒ temporarily unavailable.
- **Key Characteristic**: Uses a single global environment with an undo stack to track modifications
- **Restoration**: When done with Ïƒâ€², undo the modifications to restore Ïƒ

### 2.2 Key Differences in Insertion Operations

| Aspect | Functional Style | Imperative Style |
|--------|------------------|------------------|
| **Insertion** | Create new table structure; original remains unchanged | Modify existing table in-place |
| **Original Table** | Always available for lookup | Temporarily unavailable during modification |
| **Restoration** | Simply return to previous table reference | Must undo modifications using a stack |
| **Implementation** | Binary search trees (efficient for functional operations) | Hash tables with external chaining |
| **Memory** | Creates new nodes (only d nodes for depth d insertion) | Reuses existing structure with undo capability |

**Example of Insertion Difference:**

For Functional Style:
`*3
Ïƒâ‚ = {a â†¦ int, b â†¦ int}
Ïƒâ‚‚ = Ïƒâ‚ + {j â†¦ int}  // Ïƒâ‚ still exists unchanged
Ïƒâ‚ƒ = Ïƒâ‚‚ + {a â†¦ string}  // Ïƒâ‚‚ still exists unchanged
`*3

For Imperative Style:
`*3
Ïƒâ‚ = {a â†¦ int, b â†¦ int}
Modify Ïƒâ‚ to add {j â†¦ int} â†’ Ïƒâ‚ becomes Ïƒâ‚‚
Modify Ïƒâ‚‚ to add {a â†¦ string} â†’ Ïƒâ‚‚ becomes Ïƒâ‚ƒ
Must undo to get back to Ïƒâ‚‚, then Ïƒâ‚
`*3

---

## 3. Code Implementation Details

### 3.1 Imperative Symbol Table Implementation

#### **Hash Function**
`*3c
struct bucket { string key; void *binding; struct bucket *next; };

#define SIZE 109

struct bucket *table[SIZE];

unsigned int hash(char *s0)
{ unsigned int h=0; char *s;
  for(s=s0; *s; s++)
    h=h*65599 + *s; 
  return h; 
}
`*3
**Explanation:**
- Uses a hash table with SIZE=109 buckets (prime number for better distribution)
- Hash function: h = (câ‚Ã—65599^(n-1) + câ‚‚Ã—65599^(n-2) + ... + câ‚™â‚‹â‚Ã—65599 + câ‚™)
- Each bucket is a linked list for handling collisions (external chaining)
- The multiplier 65599 is chosen to minimize collisions for typical identifier strings

#### **Bucket Creation**
`*3c
struct bucket *Bucket (string key, void *binding, struct bucket *next) {
  struct bucket *b=checked_malloc(sizeof(*b));
  b->key = key; b->binding = binding; b->next = next;
  return b; 
}
`*3
**Explanation:**
- Creates a new bucket node for the hash table
- `checked_malloc`: allocates memory with error checking
- `void *binding`: generic pointer allows storing any type (int, string, type info, etc.)
- `next`: pointer to the next bucket in the collision chain

#### **Insert Operation**
`*3c
void insert(string key, void *binding) {
  int index=hash(key)%SIZE;
  table[index]=Bucket(key, binding, table[index]); 
}
`*3
**Explanation:**
- Computes hash index: `hash(key) % SIZE`
- Inserts new binding at the HEAD of the collision chain
- The old chain becomes the `next` pointer of the new bucket
- This allows shadowing: if `a â†¦ Ï„â‚` exists and we insert `a â†¦ Ï„â‚‚`, the new binding shadows the old
- **Important**: This stack-like behavior (LIFO) is crucial for scope management

#### **Lookup Operation**
`*3c
void *lookup(string key) {
  int index=hash(key)%SIZE 
  struct bucket *b;
  for (b = table[index]; b; b=b->next) 
    if (0==strcmp(b->key,key)) 
      return b->binding; 
  return NULL; 
}
`*3
**Explanation:**
- Computes the hash index
- Traverses the collision chain at that index
- Uses `strcmp` to compare strings character-by-character
- Returns the FIRST matching binding (most recent due to head insertion)
- Returns NULL if identifier not found

#### **Pop Operation**
`*3c
void pop(string key) { 
  int index=hash(key)%SIZE
  table[index]=table[index].next; 
}
`*3
**Explanation:**
- Removes the head element from the collision chain
- This "undoes" the most recent insertion for this key
- Works in stack-like fashion (LIFO)
- If `a â†¦ Ï„â‚‚` was inserted over `a â†¦ Ï„â‚`, popping removes Ï„â‚‚ and restores Ï„â‚

**Scope Management Example:**
`*3
Initial: hash(a) â†’ <a, int>
After insertion: hash(a) â†’ <a, string> â†’ <a, int>
After pop: hash(a) â†’ <a, int>
`*3

### 3.2 Functional Symbol Table Implementation

#### **Binary Search Tree Approach**
`*3
Functional insertion creates new nodes along the path from root to insertion point.

Example: mâ‚ = {bat â†¦ 1, camel â†¦ 2, dog â†¦ 3}
         mâ‚‚ = mâ‚ + {mouse â†¦ 4}

Tree structure:
       dog(3)              dog(3)
      /     \             /     \
   bat(1)  camel(2)    bat(1)  mouse(4)
                                /
                            camel(2)
      mâ‚                      mâ‚‚
`*3
**Explanation:**
- Only nodes from root to insertion point are copied
- Other subtrees are shared between mâ‚ and mâ‚‚
- mâ‚ remains unchanged and accessible
- Lookup time: O(log n) for balanced tree
- Insertion creates at most d new nodes (where d = depth)

**Why Hash Tables Don't Work for Functional Style:**
`*3
Problem: If we modify hash(mouse) â†’ <mouse, 4>, we lose access to mâ‚
Solution: Would need to copy the entire array (inefficient for large tables)
`*3

### 3.3 Symbol Module (Tiger Compiler Optimization)

#### **Symbol Structure and Creation**
`*3c
static S_symbol mksymbol (string name , S_symbol next) {
  S_symbol s = checked_malloc(sizeof(*s));
  s->name = name; s->next = next;
  return s;
}

S_symbol S_symbol (string name) {
	int index = hash(name)%SIZE;
	S_symbol syms = hashtable[index], sym;
	for ( sym = syms; sym; sym = sym->next)
	  if (0 == strcmp(sym->name, name)) return sym;
	sym = mksymbol(name,syms);
	hashtable[index] = sym;
   return sym;
}

string S_name (S_symbol sym) {
  return sym->name;
}
`*3
**Explanation:**
- **Purpose**: Converts strings to symbols for efficiency
- **Symbol Interning**: Each unique string is stored only once
- If "mouse" is converted to a symbol twice, it returns the SAME symbol pointer
- **Benefits**:
  1. Hash key extraction: Use pointer value directly (no string hashing needed)
  2. Equality comparison: Simple pointer comparison instead of strcmp
  3. Ordering comparison: Fast pointer comparison for binary search trees
- **How it works**:
  - Maintains a global symbol hash table
  - First call to `S_symbol("mouse")` creates and stores the symbol
  - Subsequent calls return the existing symbol pointer

### 3.4 Symbol Table Interface (Tiger Compiler)

`*3c
typedef struct S_symbol_ *S_symbol;
S_symbol S_symbol (string);
string S_name(S_symbol);

typedef struct TAB_table_ *S_table;
S_table S_empty( void);
void S_enter( S_table t,S_symbol sym, void *value); 
void *S_look( S_table t, S_symbol sym);
void S_beginScope( S_table t); 
void S_endScope( S_table t);
`*3
**Explanation:**
- `S_symbol`: Type for symbols (interned strings)
- `S_table`: Type for symbol tables
- `S_empty()`: Creates a new empty symbol table
- `S_enter()`: Inserts a binding (symbol â†’ value)
- `S_look()`: Looks up a symbol's binding
- `S_beginScope()`: Marks the beginning of a new scope
- `S_endScope()`: Restores table to state before last beginScope
- `void *value`: Generic pointer for flexibility (can store type info, variable info, etc.)

### 3.5 Symbol Table Implementation (Tiger Compiler)

#### **Basic Operations**
`*3c
// make a new S_Table
S_table S_empty(void) {
  return TAB_empty(); 
}

// insert a binding
void S_enter(S_table t, S_symbol sym, void *value){ 
  TAB_enter(t,sym,value);
} 

// look up a symbol
void *S_look(S_table t, S_symbol sym) { 
  return TAB_look(t,sym); 
}
`*3
**Explanation:**
- Wrapper functions around generic TAB module
- TAB module implements the actual hash table
- Separation allows reusing hash table for different purposes

#### **Scope Management with Markers**
`*3c
static struct S_symbol_ marksym = { "<mark>", 0 };

void S_beginScope ( S_table t) { 
  S_enter(t, &marksym, NULL); 
}

void S_endScope( S_table t) {
  S_symbol s;
  do 
    s= TAB_pop(t); 
  while (s != &marksym);
}
`*3
**Explanation:**
- **marksym**: Special marker symbol to indicate scope boundaries
- `S_beginScope()`: Inserts marker into table
- `S_endScope()`: Pops symbols until it finds the marker
- **How it works**:
  1. Enter scope: push marker
  2. Add bindings: push normal symbols
  3. Exit scope: pop until marker is found (marker is also popped)
- This ensures all bindings added in the scope are removed

#### **Auxiliary Stack Integration**
`*3c
struct TAB_table_ {
  binder table[TABSIZE];
  void *top;
};

t->table[index] = Binder(key, value,t->table[index], t->top);

static binder Binder(void *key, void *value, binder next, void *prevtop) {
  binder b = checked_malloc(sizeof(*b));
  b->key = key; b->value=value; b->next=next; 
  b->prevtop = prevtop;
  return b;
}
`*3
**Explanation:**
- **Auxiliary Stack**: Tracks insertion order for proper scope restoration
- **top**: Global pointer to most recently added binding
- **prevtop**: Each binder stores the previous top value
- **How it works**:
  1. When inserting: save current `top` in new binder's `prevtop`
  2. Update `top` to point to new binder
  3. When popping: follow `prevtop` chain to restore previous state
- **Benefits**: No separate stack needed; integrated into binder structure

**Visual Example:**
`*3
Initial state: top = NULL

Insert a: top â†’ <a, int, next, prevtop=NULL>
Insert b: top â†’ <b, int, next, prevtop=<a,...>>
Insert c: top â†’ <c, string, next, prevtop=<b,...>>

Pop c: top = prevtop of c = <b,...>
Pop b: top = prevtop of b = <a,...>
`*3

---

## 4. Scope and Environment Management

### Example Code Analysis
`*3c
1 function f(a:int,b:int,c:int)=
2   (print_int (a+c);
3   let var j:= a+b
4       var a:= "hello"
5   in print(a); print_int(j)
6   end;
7   print_int(b)
8   )
`*3

**Environment Evolution:**
- **Ïƒâ‚€** = {g â†¦ string, a â†¦ int} (initial/global environment)
- **Line 1**: Ïƒâ‚ = Ïƒâ‚€ + {a â†¦ int, b â†¦ int, c â†¦ int}
- **Line 3**: Ïƒâ‚‚ = Ïƒâ‚ + {j â†¦ int}
- **Line 4**: Ïƒâ‚ƒ = Ïƒâ‚‚ + {a â†¦ string}  (shadows the a â†¦ int from Ïƒâ‚)
- **Line 6**: Discard Ïƒâ‚ƒ, restore Ïƒâ‚
- **Line 8**: Discard Ïƒâ‚, restore Ïƒâ‚€

**Key Points:**
- Bindings in the right-hand table override those in the left
- Ïƒ + {a â†¦ string} â‰  {a â†¦ string} + Ïƒ (order matters!)
- At line 5: `print(a)` uses a â†¦ string from Ïƒâ‚ƒ
- At line 5: `print_int(j)` uses j â†¦ int from Ïƒâ‚‚ (still visible in Ïƒâ‚ƒ)
- At line 7: `print_int(b)` uses b â†¦ int from Ïƒâ‚

---

## 5. Multiple Symbol Tables (Java vs ML)

### Java Example (Forward References Allowed)
`*3java
package M;
class E { static int a = 5; }
class N { static int b = 10; static int a = E.a + b; }
class D { static int d = E.a + N.a; }
`*3

**Environment Construction:**
- Ïƒâ‚ = {a â†¦ int}
- Ïƒâ‚‚ = {E â†¦ Ïƒâ‚}
- Ïƒâ‚ƒ = {b â†¦ int, a â†¦ int}
- Ïƒâ‚„ = {N â†¦ Ïƒâ‚ƒ}
- Ïƒâ‚… = {d â†¦ int}
- Ïƒâ‚† = {D â†¦ Ïƒâ‚…}
- Ïƒâ‚‡ = Ïƒâ‚‚ + Ïƒâ‚„ + Ïƒâ‚†

**Key**: All classes (E, N, D) are compiled in environment Ïƒâ‚‡, allowing forward references.

### ML Example (Sequential Processing)
`*3ml
structure M = struct 
   structure E = struct val a = 5; end 
   structure N = struct val b = 10; val a = E.a + b; end 
   structure D = struct val d = E.a + N.a; end 
end
`*3

**Environment Construction:**
- N is compiled using Ïƒâ‚€ + Ïƒâ‚‚ (can see E but not D)
- D is compiled using Ïƒâ‚€ + Ïƒâ‚‚ + Ïƒâ‚„ (can see E and N)
- No forward references allowed

---

## 6. Homework Assignment Explanations

### Question 1: Symbol Table Restoration Methods
**Question**: Which implementation method accomplishes "restore" operation with minimal overhead (manipulating a few pointers rather than large-scale copy)?

**Answer**: D (Both B and C are correct)

**Explanation**:
- **Option B (Functional Binary Search Tree)**: When adding a new binding at depth d, only d new nodes are created along the path from root to insertion point. All other nodes are shared. Restoration is simply using the old tree reference - no copying needed.
- **Option C (Imperative Hash Table with Undo Stack)**: The hash table itself isn't copied. Instead, an undo stack records modifications. Restoration involves popping entries from the stack and reversing the modifications by adjusting a few pointers in the collision chains.
- **Option A is WRONG**: Making a complete deep copy is expensive and defeats the purpose of efficient restoration.

### Question 2: Type of Variable 'a' at Line 8
**Question**: In the given Tiger code, what is the type bound to variable 'a' when `print(a)` on line 8 is executed?

`*3c
1 function f(a:int, b:int, c:int) =
2 (
3   print_int(a+c);
4   let 
5     var j := a+b
6     var a := "hello"
7   in 
8     print(a); 
9     print_int(j)
10  end;
11  print_int(b)
12 )
`*3

**Answer**: string

**Explanation**:
- Line 1: Ïƒâ‚ = Ïƒâ‚€ + {a â†¦ int, b â†¦ int, c â†¦ int}
- Line 5: Ïƒâ‚‚ = Ïƒâ‚ + {j â†¦ int}
- Line 6: Ïƒâ‚ƒ = Ïƒâ‚‚ + {a â†¦ string}  â† This shadows the previous a â†¦ int
- Line 8: In environment Ïƒâ‚ƒ, the most recent binding for 'a' is string
- The string binding shadows (hides) the int binding from line 1
- After line 10 (end), Ïƒâ‚ƒ is discarded and we return to Ïƒâ‚

### Question 3: Handling Duplicate Identifiers in Hash Table
**Question**: When inserting a new binding a â†¦ Ï„â‚‚ when a â†¦ Ï„â‚ already exists, what is the most efficient and scope-compliant way?

**Answer**: C (Insert the new binding a â†¦ Ï„â‚‚ at the head of the collision chain, effectively shadowing the old binding)

**Explanation**:
- **Why C is correct**:
  - Inserting at the head is O(1) - very efficient
  - Lookup finds the most recent binding first (at head)
  - When scope ends, simply pop the head to restore old binding
  - This naturally implements shadowing behavior
  - Stack-like (LIFO) behavior matches scope nesting
  
- **Why other options are wrong**:
  - **A (Overwrite)**: Loses the old binding permanently; can't restore when scope ends
  - **B (Append to end)**: O(n) to traverse to end; lookup would find old binding first (wrong!)
  - **D (Error)**: Valid to shadow variables in nested scopes; shouldn't be an error

**Example**:
`*3
Initial: hash(a) â†’ <a, Ï„â‚>
After insert: hash(a) â†’ <a, Ï„â‚‚> â†’ <a, Ï„â‚>
Lookup finds Ï„â‚‚ (correct - most recent)
After pop: hash(a) â†’ <a, Ï„â‚> (restored)
`*3

### Question 4: Optimized Data Type for Identifiers
**Question**: What is the optimized data type that Tiger compiler uses to avoid repeated character-by-character string operations?

**Answer**: Symbol

**Explanation**:
- **Problem**: String operations are expensive
  - Hash calculation: must examine every character
  - Comparison: strcmp examines characters until difference found
  - For large programs with thousands of identifiers, this adds up
  
- **Solution**: Symbol (String Interning)
  - Convert each unique string to a Symbol once
  - Store only one copy of each unique string
  - Symbol is represented as a pointer
  
- **Benefits**:
  1. **Hash key**: Use pointer value directly (no string hashing)
  2. **Equality**: Pointer comparison instead of strcmp (O(1) vs O(n))
  3. **Ordering**: Pointer comparison for BST operations
  
- **Example**:
  `*3c
  S_symbol sym1 = S_symbol("mouse");  // Creates symbol
  S_symbol sym2 = S_symbol("mouse");  // Returns same symbol
  // sym1 == sym2 (same pointer!)
  `*3

### Question 5: Handling Forward References in Java
**Question**: How does the symbol table system handle forward references in Java where a class member can reference a later-defined class?

**Answer**: B (Each class has its own symbol table, combined into a comprehensive environment Ïƒâ‚‡ for compilation)

**Explanation**:
- **Java's Approach**:
  1. Each class (E, N, D) has its own symbol table (Ïƒâ‚, Ïƒâ‚ƒ, Ïƒâ‚…)
  2. These are wrapped in environments (Ïƒâ‚‚, Ïƒâ‚„, Ïƒâ‚†)
  3. All are combined: Ïƒâ‚‡ = Ïƒâ‚‚ + Ïƒâ‚„ + Ïƒâ‚†
  4. Each class is compiled using the complete Ïƒâ‚‡
  5. This makes all classes visible to each other
  
- **Example**:
  `*3java
  class D { static int d = E.a + N.a; }  // D references E and N
  class E { static int a = 5; }          // E defined after D
  `*3
  Both E and N are visible when compiling D because Ïƒâ‚‡ contains all of them.

- **Why other options are wrong**:
  - **A (Single global table)**: Doesn't maintain class structure; loses namespace information
  - **C (Sequential order)**: This is ML's approach, not Java's; doesn't allow forward references
  - **D (Stack-based)**: Doesn't solve forward reference problem; would only see previous classes

---

## 7. Summary of Key Concepts

### Functional vs Imperative Trade-offs
| Aspect | Functional | Imperative |
|--------|-----------|------------|
| **Data Structure** | Binary Search Tree | Hash Table |
| **Lookup Time** | O(log n) | O(1) average |
| **Insert Time** | O(log n) | O(1) |
| **Space** | New nodes created | Reuses structure |
| **Restoration** | Keep old reference | Undo modifications |
| **Complexity** | Simpler conceptually | Requires undo mechanism |

### Important Implementation Details
1. **Hash Function**: Uses multiplier 65599 for good distribution
2. **External Chaining**: Handles collisions with linked lists
3. **Head Insertion**: Enables efficient shadowing and restoration
4. **Symbol Interning**: Converts strings to symbols for efficiency
5. **Marker Symbols**: Special symbols mark scope boundaries
6. **Auxiliary Stack**: Integrated into binder structure via prevtop field

### Scope Management Principles
1. **Shadowing**: Inner scope bindings hide outer scope bindings
2. **Restoration**: Exit scope restores previous environment
3. **Stack Discipline**: Scopes follow LIFO (Last In, First Out)
4. **Markers**: Special entries mark scope boundaries
5. **Undo Stack**: Tracks modifications for restoration

---

## End of Notes

These notes cover the key concepts from Chapter 5 on Semantic Analysis and Symbol Tables, including detailed code explanations and homework assignment solutions. Good luck with your studies!


```

```json output_result
Successfully wrote to /workspace/dumps/workspace/NOTE.md
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Perfect! I've created a comprehensive study note for you. Let me summarize what I've included:

## Summary of Your Study Notes (NOTE.md)

I've created a detailed study guide that covers:

### 1. **Functional vs Imperative Symbol Tables**
   - **Definitions**: Clear explanation of both approaches
   - **Key Differences**: Comparison table showing how insertion operations differ
   - Functional keeps original tables unchanged; Imperative modifies in-place with undo capability

### 2. **Complete Code Explanations**
   I've included ALL the code from the presentation with detailed explanations:
   
   **Imperative Implementation:**
   - Hash function and bucket structure
   - Insert operation (head insertion for shadowing)
   - Lookup operation (traverses collision chain)
   - Pop operation (removes head for restoration)
   
   **Functional Implementation:**
   - Binary search tree approach
   - Why hash tables don't work for functional style
   
   **Tiger Compiler Optimization:**
   - Symbol module (string interning)
   - Symbol table interface
   - Scope management with markers
   - Auxiliary stack integration

### 3. **Homework Assignment Solutions**
   Complete explanations for all 5 questions:
   - **Q1**: Why both functional BST and imperative hash table with undo stack are efficient (Answer: D)
   - **Q2**: Type of variable 'a' at line 8 (Answer: string) - with environment tracing
   - **Q3**: How to handle duplicate identifiers (Answer: C - insert at head)
   - **Q4**: Optimized data type name (Answer: Symbol)
   - **Q5**: Java's forward reference handling (Answer: B - combined environment approach)

### 4. **Additional Study Materials**
   - Scope and environment management examples
   - Multiple symbol tables (Java vs ML comparison)
   - Trade-offs summary table
   - Key implementation principles

The notes are well-organized with clear headings, code blocks, explanations, and examples to help you understand the lecture material you missed. Good luck with your studies!
</div>

</Accordion>

<Accordion title="deepseek-v3.2">

<Columns cols={3}>
<Card title="Task Completion" icon="x">
Failed
</Card>
<Card title="Tool Calls" icon="wrench">
5
</Card>
<Card title="Turns" icon="arrows-rotate">
6
</Card>
</Columns>

<div className="thinking-box">
ğŸ§`Agent`

I'll help you study the Compiler Principles course material. Let me start by examining the presentation file and homework assignment to create comprehensive notes for you.
</div>

<div className="result-box">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48" width="14px" height="14px" style={{margin: 0, padding: 0, display: 'inline-block'}}><path fill="#FFA000" d="M40,12H22l-4-4H8c-2.2,0-4,1.8-4,4v8h40v-4C44,13.8,42.2,12,40,12z"/><path fill="#FFCA28" d="M40,12H8c-2.2,0-4,1.8-4,4v20c0,2.2,1.8,4,4,4h32c2.2,0,4-1.8,4-4V16C44,13.8,42.2,12,40,12z"/></svg> `filesystem list_directory`

<Expandable title="Details">
```json arguments
{
	"path": "/workspace/dumps/workspace"
}

```

```json output_result
[DIR] .pdf_tools_tempfiles
[FILE] Compile.pptx
[FILE] HW.pdf
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Great! I can see both files are available. Let me first examine the presentation to understand the content about symbol tables.
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx open_presentation`

<Expandable title="Details">
```json arguments
{
	"file_path": "/workspace/dumps/workspace/Compile.pptx"
}

```

```json output_result
{
  "presentation_id": "presentation_1",
  "message": "Opened presentation from /workspace/dumps/workspace/Compile.pptx with ID: presentation_1",
  "slide_count": 26
}
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Now let me extract all the text from the presentation to understand the content about functional and imperative symbol tables.
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx extract_presentation_text`

<Expandable title="Details">
```json arguments
{
	"presentation_id": "presentation_1",
	 "include_slide_info": true
}

```

```json output_result
{
  "success": true,
  "presentation_id": "presentation_1",
  "total_slides": 26,
  "slides_with_text": 26,
  "total_text_shapes": 45,
  "slides_with_titles": 26,
  "slides_with_tables": 2,
  "slides_text": [
    {
      "slide_index": 0,
      "text_content": {
        "slide_title": "Semantic Analysis\u000bChapter 5",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis\u000bChapter 5",
            "placeholder_type": "CENTER_TITLE (3)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5"
      },
      "layout_name": "æ ‡é¢˜å¹»ç¯ç‰‡",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 1,
      "text_content": {
        "slide_title": "Semantic Analysis",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 2,
      "text_content": {
        "slide_title": "Outline",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Outline",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables\nBindings for the Tiger Compiler\nType Checking",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Outline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 3,
      "text_content": {
        "slide_title": "5.1 Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "5.1 Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 4,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "ï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 5,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Each local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 6,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 7,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 8,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 9,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Imperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 10,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 11,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 12,
      "text_content": {
        "slide_title": "Effective Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Effective Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Consider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Effective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 13,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 14,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 15,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 16,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Table",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Table",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "We can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          },
          {
            "shape_index": 5,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "bat",
                  "1"
                ]
              }
            ]
          },
          {
            "shape_index": 6,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "camel",
                  "2"
                ]
              }
            ]
          },
          {
            "shape_index": 9,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          },
          {
            "shape_index": 11,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 17,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 18,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 19,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 20,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 21,
      "text_content": {
        "slide_title": "The Implementation of Symbols",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbols",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 22,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 23,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "For destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 24,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "How can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 25,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    }
  ],
  "all_presentation_text_combined": "=== SLIDE 1 ===\nSemantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5\n\n=== SLIDE 2 ===\nSemantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code\n\n=== SLIDE 3 ===\nOutline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking\n\n=== SLIDE 4 ===\n5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?\n\n=== SLIDE 5 ===\nSymbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}\n\n=== SLIDE 6 ===\nSymbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1\n\n=== SLIDE 7 ===\nSymbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack\n\n=== SLIDE 8 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}.\n\n=== SLIDE 9 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table.\n\n=== SLIDE 10 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>\n\n=== SLIDE 11 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 12 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 13 ===\nEffective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>\n\n=== SLIDE 14 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?\n\n=== SLIDE 15 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX\n\n=== SLIDE 16 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large\n\n=== SLIDE 17 ===\nEfficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2\n\n=== SLIDE 18 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 19 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 20 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)\n\n=== SLIDE 21 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);\n\n=== SLIDE 22 ===\nThe Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}\n\n=== SLIDE 23 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}\n\n=== SLIDE 24 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}\n\n=== SLIDE 25 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.\n\n=== SLIDE 26 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}\n"
}
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Now let me examine the homework PDF to understand the assignments.
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
{
	"pdf_file_path": "/workspace/dumps/workspace/HW.pdf",
	 "start_page": 1,
	 "end_page": 10
}

```

```json output_result
PDF total pages: 2
Extracted page range: 1-2

=== Page 1 ===
Compiler Principles Assignment: Semantic Analysis & Symbol Tables  
Â 
Instructions:  Based on Chapter 5 of the "Modern Compiler Implementation" presentation, please answer the  
following questions. All questions are multiple-choice or fill-in-the-blank with a single correct answer.
Question 1 (Multiple Choice)
During the semantic analysis phase, the Symbol Table is crucial. When the compiler exits a scope (e.g., after a  
function body or a let block), it must restore the symbol table to its state before entering that scope. Which  
of the following implementation methods accomplishes this "restore" operation where the primary overhead  
involves manipulating a few pointers, rather than performing a large-scale copy of the entire data structure?
A) Making a complete, deep copy of the hash-table-based symbol table upon entering the scope.
B) Using a functional-style balanced binary search tree, which only creates new nodes along the path from the  
root to the insertion point when adding a new binding.
C) Using an imperative-style hash table combined with a separate "undo stack" to log all modifications, which  
are then reversed upon exiting the scope.
D) Both B and C are correct.
Question 2 (Fill in the Blank)
In the Tiger pseudocode below, assume the initial symbol table is Ïƒ0 = {g â†¦  string, a â†¦  int}. What is the  
type bound to the variable a when the print(a) statement on line 8 is executed?
Answer:  ____
Question 3 (Multiple Choice)
When implementing an imperative-style symbol table using a hash table with external chaining to resolve  
collisions, what is the most efficient and scope-compliant way to handle the insertion of a new binding a â†¦ 
Ï„2 when an older binding a â†¦ Ï„1 for the same identifier a already exists within the table?1 function f(a:int, b:int, c:int) =
2 (
3 Â  print_int(a+c);
4 Â  let 
5 Â  Â  var j := a+b
6 Â  Â  var a := "hello"
7 Â  in 
8 Â  Â  print(a); 
9 Â  Â  print_int(j)
10  end;
11  print_int(b)
12 )1
2
3
4
5
6
7
8
9
10
11
12


=== Page 2 ===
A) Traverse the collision chain to find and overwrite the old binding a â†¦  Ï„ 1.
B) Append the new binding a â†¦  Ï„ 2 to the end of the collision chain.
C) Insert the new binding a â†¦  Ï„ 2 at the head of the collision chain, effectively shadowing the old binding.
D) Throw a "variable redefined" compilation error.
Question 4 (Fill in the Blank)
To improve the efficiency of symbol table operations, particularly the cost of string lookups and comparisons,  
the Tiger compiler employs an optimization. It converts string identifiers into a unique, fixed-size data type. All  
subsequent hash calculations and equality checks are performed on this new type, avoiding repeated,  
character-by-character operations on the original strings. This optimized data type is referred to in the  
presentation as a ____.
Answer:  ____
Question 5 (Multiple Choice)
When processing a language like Java that allows forward references, a member of one class can reference a  
member of another class that is defined later in the source code. How is this typically handled by the symbol  
table system to ensure all symbols are visible when needed?
A) A single, global symbol table is used, and all members from all classes are placed directly into it.
B) Each class (E, N, D) has its own symbol table, which are then combined (e.g., Ïƒ 2 + Ïƒ 4 + Ïƒ 6) into a single,  
comprehensive environment Ïƒ 7 representing the entire package. This combined environment is then used for  
compiling the classes within it.
C) The compiler processes declarations in strict sequential order, so when compiling D, it can only see symbols  
from E and N if they have already been fully analyzed.
D) A stack-based symbol table is used, pushing a class's table onto the stack when entering it and popping it off  
when exiting.
Â 
Â // package M;
class E { static int a = 5; }
class N { static int b = 10; static int a = E.a + b; }
class D { static int d = E.a + N.a; }1
2
3
4

```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Now let me create the comprehensive notes file with all the information you requested.
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
workspace/NOTE.md
# Compiler Principles - Chapter 5: Semantic Analysis Notes

## 1. Functional vs Imperative Symbol Tables

### Functional Symbol Tables
- **Definition**: Keep the original symbol table (Ïƒâ‚) in pristine condition while creating new tables (Ïƒâ‚‚, Ïƒâ‚ƒ)
- **Insertion Operation**: Creates a new table by computing the "sum" of an existing table and a new binding
- **Key Characteristic**: Does NOT modify the original table - both old and new tables remain available
- **Implementation**: Typically uses balanced binary search trees
- **Advantage**: Easy to restore previous states
- **Disadvantage**: Requires creating new nodes (though only along the insertion path)

### Imperative Symbol Tables  
- **Definition**: Modify the existing symbol table (Ïƒâ‚) until it becomes the new table (Ïƒâ‚‚)
- **Insertion Operation**: Directly modifies the global environment
- **Key Characteristic**: Uses a single global environment + undo stack
- **Implementation**: Typically uses hash tables with external chaining
- **Advantage**: More memory efficient
- **Disadvantage**: Cannot access previous states while new state exists

### Key Differences in Insertion Operations
- **Functional**: Creates new tables without modifying originals (non-destructive)
- **Imperative**: Modifies existing tables directly (destructive)
- **Functional**: Better for maintaining multiple environments simultaneously
- **Imperative**: Better for memory efficiency in single-threaded compilation

## 2. Code Examples from Presentation

### Imperative Symbol Table Implementation (Hash Table)

#### Data Structures:
`*3c
struct bucket { 
    string key; 
    void *binding; 
    struct bucket *next; 
};

#define SIZE 109
struct bucket *table[SIZE];
`*3

#### Hash Function:
`*3c
unsigned int hash(char *s0) {
    unsigned int h = 0; 
    char *s;
    for(s = s0; *s; s++)
        h = h * 65599 + *s; 
    return h; 
}
`*3

#### Bucket Creation:
`*3c
struct bucket *Bucket(string key, void *binding, struct bucket *next) {
    struct bucket *b = checked_malloc(sizeof(*b));
    b->key = key; 
    b->binding = binding; 
    b->next = next;
    return b; 
}
`*3

#### Core Operations:
`*3c
void insert(string key, void *binding) {
    int index = hash(key) % SIZE;
    table[index] = Bucket(key, binding, table[index]); 
}

void *lookup(string key) {
    int index = hash(key) % SIZE;
    struct bucket *b;
    for (b = table[index]; b; b = b->next) 
        if (0 == strcmp(b->key, key)) 
            return b->binding; 
    return NULL; 
}

void pop(string key) { 
    int index = hash(key) % SIZE;
    table[index] = table[index].next; 
}
`*3

### Tiger Compiler Symbol Implementation

#### Symbol Interface:
`*3c
typedef struct S_symbol_ *S_symbol;
S_symbol S_symbol(string);
string S_name(S_symbol);

typedef struct TAB_table_ *S_table;
S_table S_empty(void);
void S_enter(S_table t, S_symbol sym, void *value); 
void *S_look(S_table t, S_symbol sym);
void S_beginScope(S_table t); 
void S_endScope(S_table t);
`*3

#### Symbol Implementation:
`*3c
static S_symbol mksymbol(string name, S_symbol next) {
    S_symbol s = checked_malloc(sizeof(*s));
    s->name = name; 
    s->next = next;
    return s;
}

S_symbol S_symbol(string name) {
    int index = hash(name) % SIZE;
    S_symbol syms = hashtable[index], sym;
    for (sym = syms; sym; sym = sym->next)
        if (0 == strcmp(sym->name, name)) 
            return sym;
    sym = mksymbol(name, syms);
    hashtable[index] = sym;
    return sym;
}

string S_name(S_symbol sym) {
    return sym->name;
}
`*3

#### Symbol Table Implementation:
`*3c
// Make a new S_Table
S_table S_empty(void) {
    return TAB_empty(); 
}

// Insert a binding
void S_enter(S_table t, S_symbol sym, void *value) { 
    TAB_enter(t, sym, value);
} 

// Look up a symbol
void *S_look(S_table t, S_symbol sym) { 
    return TAB_look(t, sym); 
}
`*3

#### Scope Management:
`*3c
static struct S_symbol_ marksym = { "<mark>", 0 };

void S_beginScope(S_table t) { 
    S_enter(t, &marksym, NULL); 
}

void S_endScope(S_table t) {
    S_symbol s;
    do 
        s = TAB_pop(t); 
    while (s != &marksym);
}
`*3

#### Advanced Implementation with Auxiliary Stack:
`*3c
struct TAB_table_ {
    binder table[TABSIZE];
    void *top;
};

t->table[index] = Binder(key, value, t->table[index], t->top);

static binder Binder(void *key, void *value, binder next, void *prevtop) {
    binder b = checked_malloc(sizeof(*b));
    b->key = key; 
    b->value = value; 
    b->next = next; 
    b->prevtop = prevtop;
    return b;
}
`*3

## 3. Homework Assignment Analysis

### Question 1: Scope Restoration Methods
**Correct Answer**: D) Both B and C are correct
- **B**: Functional-style balanced binary search tree - only creates new nodes along insertion path
- **C**: Imperative-style hash table with undo stack - logs modifications for reversal

### Question 2: Variable Type Analysis
**Answer**: string
- Initial: Ïƒâ‚€ = {g â†¦ string, a â†¦ int}
- Line 1: Ïƒâ‚ = Ïƒâ‚€ + {a â†¦ int, b â†¦ int, c â†¦ int}  
- Line 4: Ïƒâ‚‚ = Ïƒâ‚ + {a â†¦ string} (shadows previous a â†¦ int)
- Line 8: print(a) uses the most recent binding a â†¦ string

### Question 3: Hash Table Collision Handling
**Correct Answer**: C) Insert the new binding at the head of the collision chain
- This shadows the old binding efficiently
- Allows easy restoration via pop operation
- Maintains scope semantics correctly

### Question 4: Symbol Optimization
**Answer**: Symbol
- Tiger compiler converts strings to unique "Symbol" data type
- Enables fast hash calculations and equality checks
- Avoids repeated character-by-character operations

### Question 5: Forward Reference Handling
**Correct Answer**: B) Each class has its own symbol table, combined into comprehensive environment
- Ïƒâ‚‚ = {E â†¦ Ïƒâ‚}, Ïƒâ‚„ = {N â†¦ Ïƒâ‚ƒ}, Ïƒâ‚† = {D â†¦ Ïƒâ‚…}
- Ïƒâ‚‡ = Ïƒâ‚‚ + Ïƒâ‚„ + Ïƒâ‚† (combined environment)
- All classes compiled in environment Ïƒâ‚‡, allowing forward references

## 4. Key Concepts Summary

### Symbol Table Operations
- **Add**: Insert new bindings
- **Lookup**: Find existing bindings  
- **Undo**: Remove bindings when exiting scope

### Implementation Strategies
- **Hash Tables**: Fast lookup, efficient for imperative style
- **Binary Search Trees**: Efficient for functional style, only copy insertion path
- **Symbol Optimization**: Convert strings to unique identifiers for performance

### Scope Management
- **beginScope**: Mark current state
- **endScope**: Restore to marked state
- **Auxiliary Stack**: Track binding order for efficient restoration

### Multiple Environments
- **Java/ML**: Each class/structure has own symbol table
- **Combined Environment**: Multiple tables summed for comprehensive lookup
- **Forward References**: Enabled by combined environment approach

```

```json output_result
Successfully wrote to /workspace/dumps/workspace/NOTE.md
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Perfect! I've created comprehensive notes for your Compiler Principles course. The `NOTE.md` file now contains:

## What's Included:

1. **Functional vs Imperative Symbol Tables**: Clear definitions and differences in insertion operations
   - Functional: Non-destructive, keeps original tables pristine
   - Imperative: Destructive, modifies existing tables with undo stack

2. **Complete Code Examples**: All the original code from the presentation including:
   - Hash table implementation with buckets
   - Hash function using polynomial hashing
   - Core operations (insert, lookup, pop)
   - Tiger compiler symbol interface and implementation
   - Scope management with beginScope/endScope
   - Advanced implementation with auxiliary stack

3. **Homework Analysis**: Detailed explanations for all 5 questions:
   - Question 1: Scope restoration methods (Answer: D)
   - Question 2: Variable type analysis (Answer: string)  
   - Question 3: Hash collision handling (Answer: C)
   - Question 4: Symbol optimization (Answer: Symbol)
   - Question 5: Forward reference handling (Answer: B)

4. **Key Concepts Summary**: Concise overview of symbol table operations, implementation strategies, scope management, and multiple environments.

The notes are structured to help you understand both the theoretical concepts and practical implementations discussed in the lecture. You now have a comprehensive study guide that covers everything you missed due to illness!
</div>

</Accordion>

<Accordion title="gemini-2.5-flash">

<Columns cols={3}>
<Card title="Task Completion" icon="x">
Failed
</Card>
<Card title="Tool Calls" icon="wrench">
6
</Card>
<Card title="Turns" icon="arrows-rotate">
7
</Card>
</Columns>

<div className="result-box">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48" width="14px" height="14px" style={{margin: 0, padding: 0, display: 'inline-block'}}><path fill="#FFA000" d="M40,12H22l-4-4H8c-2.2,0-4,1.8-4,4v8h40v-4C44,13.8,42.2,12,40,12z"/><path fill="#FFCA28" d="M40,12H8c-2.2,0-4,1.8-4,4v20c0,2.2,1.8,4,4,4h32c2.2,0,4-1.8,4-4V16C44,13.8,42.2,12,40,12z"/></svg> `filesystem list_directory`

<Expandable title="Details">
```json arguments
{
	"path":"/workspace/dumps/workspace"
}

```

```json output_result
[DIR] .pdf_tools_tempfiles
[FILE] Compile.pptx
[FILE] HW.pdf
```

</Expandable>
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx list_slide_templates`

<Expandable title="Details">
```json arguments
{}

```

```json output_result
{
  "available_templates": [
    {
      "id": "title_slide",
      "name": "Dynamic Title Slide",
      "description": "Main title slide with gradient background and text effects",
      "layout_type": "title",
      "element_count": 4
    },
    {
      "id": "text_with_image",
      "name": "Dynamic Text + Image",
      "description": "Text content with stylized image and interactive elements",
      "layout_type": "content",
      "element_count": 6
    },
    {
      "id": "two_column_text",
      "name": "Two Columns of Text",
      "description": "Two equal columns of text content with dynamic sizing",
      "layout_type": "content",
      "element_count": 3
    },
    {
      "id": "two_column_text_images",
      "name": "Two Columns Text + Images",
      "description": "Two columns with text and corresponding images with effects",
      "layout_type": "content",
      "element_count": 5
    },
    {
      "id": "three_column_layout",
      "name": "Three Columns Text + Images",
      "description": "Three equal columns with text and images with effects",
      "layout_type": "content",
      "element_count": 7
    },
    {
      "id": "agenda_slide",
      "name": "Agenda/Directory Page",
      "description": "Table of contents or agenda overview with styling",
      "layout_type": "content",
      "element_count": 3
    },
    {
      "id": "chapter_intro",
      "name": "Chapter Introduction Page",
      "description": "Section divider with chapter number and title with effects",
      "layout_type": "content",
      "element_count": 4
    },
    {
      "id": "thank_you_slide",
      "name": "Thank You/End Page",
      "description": "Closing slide with contact information and effects",
      "layout_type": "content",
      "element_count": 3
    },
    {
      "id": "timeline_slide",
      "name": "Timeline Page",
      "description": "Horizontal timeline with milestones and effects",
      "layout_type": "content",
      "element_count": 10
    },
    {
      "id": "data_table_slide",
      "name": "Data Table Page",
      "description": "Slide focused on tabular data presentation with styling",
      "layout_type": "content",
      "element_count": 3
    },
    {
      "id": "chart_comparison",
      "name": "Chart Comparison Page",
      "description": "Two charts side by side for comparison with effects",
      "layout_type": "content",
      "element_count": 4
    },
    {
      "id": "full_image_slide",
      "name": "Full Image with Overlay Text",
      "description": "Large background image with text overlay and effects",
      "layout_type": "content",
      "element_count": 4
    },
    {
      "id": "process_flow",
      "name": "Process Flow Diagram",
      "description": "Step-by-step process visualization with enhanced effects",
      "layout_type": "content",
      "element_count": 13
    },
    {
      "id": "quote_testimonial",
      "name": "Quote/Testimonial Slide",
      "description": "Featured quote or customer testimonial with effects",
      "layout_type": "content",
      "element_count": 3
    },
    {
      "id": "key_metrics_dashboard",
      "name": "KPI Dashboard",
      "description": "Interactive metrics dashboard with animated counters and effects",
      "layout_type": "content",
      "element_count": 11
    },
    {
      "id": "before_after_comparison",
      "name": "Before/After Comparison",
      "description": "Dynamic comparison layout with visual dividers and effects",
      "layout_type": "content",
      "element_count": 9
    },
    {
      "id": "team_introduction",
      "name": "Team Introduction",
      "description": "Team member showcase with photos, roles and effects",
      "layout_type": "content",
      "element_count": 11
    },
    {
      "id": "minimalist_hero",
      "name": "Minimalist Hero Slide",
      "description": "Clean, spacious design with bold typography and minimal elements",
      "layout_type": "content",
      "element_count": 2
    },
    {
      "id": "neon_cyberpunk",
      "name": "Neon Cyberpunk Slide",
      "description": "Futuristic design with neon colors and cyber elements",
      "layout_type": "content",
      "element_count": 3
    },
    {
      "id": "nature_organic",
      "name": "Organic Nature Slide",
      "description": "Earth-toned design with organic shapes and natural textures",
      "layout_type": "content",
      "element_count": 4
    },
    {
      "id": "interactive_poll",
      "name": "Interactive Poll Slide",
      "description": "Engaging poll slide with interactive elements and real-time visualization",
      "layout_type": "content",
      "element_count": 11
    },
    {
      "id": "split_screen_comparison",
      "name": "Split Screen Comparison",
      "description": "Modern split-screen layout for comparing two concepts or solutions",
      "layout_type": "content",
      "element_count": 8
    },
    {
      "id": "product_showcase",
      "name": "Product Showcase",
      "description": "Modern product presentation with custom image masks and interactive elements",
      "layout_type": "content",
      "element_count": 8
    }
  ],
  "total_templates": 23,
  "usage_examples": {
    "single_slide_example": {
      "description": "Apply a single template to a slide",
      "code": {
        "template_id": "text_with_image",
        "color_scheme": "modern_blue",
        "content_mapping": {
          "title": "Our Solution",
          "content": "â€¢ Increased efficiency by 40%\nâ€¢ Reduced costs significantly\nâ€¢ Improved user satisfaction"
        },
        "image_paths": {
          "supporting": "/path/to/solution_image.jpg"
        }
      }
    },
    "presentation_sequence_example": {
      "description": "Create a complete presentation from templates",
      "code": [
        {
          "template_id": "title_slide",
          "content": {
            "title": "2024 Business Review",
            "subtitle": "Annual Performance Report",
            "author": "John Smith, CEO"
          }
        },
        {
          "template_id": "agenda_slide",
          "content": {
            "agenda_items": "1. Executive Summary\n\n2. Financial Performance\n\n3. Market Analysis\n\n4. Future Strategy"
          }
        },
        {
          "template_id": "key_metrics_dashboard",
          "content": {
            "metric_1_value": "92%",
            "metric_2_value": "$3.2M",
            "metric_3_value": "340",
            "metric_4_value": "18%"
          }
        },
        {
          "template_id": "thank_you_slide",
          "content": {
            "contact": "Questions?\njohn.smith@company.com\n(555) 123-4567"
          }
        }
      ]
    },
    "available_templates": [
      "title_slide",
      "text_with_image",
      "two_column_text",
      "two_column_text_images",
      "three_column_layout",
      "agenda_slide",
      "chapter_intro",
      "thank_you_slide",
      "timeline_slide",
      "data_table_slide",
      "chart_comparison",
      "full_image_slide",
      "process_flow",
      "quote_testimonial",
      "key_metrics_dashboard",
      "before_after_comparison",
      "team_introduction"
    ],
    "color_schemes": [
      "modern_blue",
      "corporate_gray",
      "elegant_green",
      "warm_red"
    ]
  },
  "message": "Use apply_slide_template to apply templates to slides"
}
```

</Expandable>
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx open_presentation`

<Expandable title="Details">
```json arguments
{
	"file_path":"Compile.pptx"
}

```

```json output_result
{
  "presentation_id": "presentation_1",
  "message": "Opened presentation from Compile.pptx with ID: presentation_1",
  "slide_count": 26
}
```

</Expandable>
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx extract_presentation_text`

<Expandable title="Details">
```json arguments
{
	"presentation_id":"presentation_1"
}

```

```json output_result
{
  "success": true,
  "presentation_id": "presentation_1",
  "total_slides": 26,
  "slides_with_text": 26,
  "total_text_shapes": 45,
  "slides_with_titles": 26,
  "slides_with_tables": 2,
  "slides_text": [
    {
      "slide_index": 0,
      "text_content": {
        "slide_title": "Semantic Analysis\u000bChapter 5",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis\u000bChapter 5",
            "placeholder_type": "CENTER_TITLE (3)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5"
      },
      "layout_name": "æ ‡é¢˜å¹»ç¯ç‰‡",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 1,
      "text_content": {
        "slide_title": "Semantic Analysis",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 2,
      "text_content": {
        "slide_title": "Outline",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Outline",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables\nBindings for the Tiger Compiler\nType Checking",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Outline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 3,
      "text_content": {
        "slide_title": "5.1 Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "5.1 Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 4,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "ï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 5,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Each local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 6,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 7,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 8,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 9,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Imperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 10,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 11,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 12,
      "text_content": {
        "slide_title": "Effective Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Effective Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Consider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Effective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 13,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 14,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 15,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 16,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Table",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Table",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "We can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          },
          {
            "shape_index": 5,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "bat",
                  "1"
                ]
              }
            ]
          },
          {
            "shape_index": 6,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "camel",
                  "2"
                ]
              }
            ]
          },
          {
            "shape_index": 9,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          },
          {
            "shape_index": 11,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 17,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 18,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 19,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 20,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 21,
      "text_content": {
        "slide_title": "The Implementation of Symbols",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbols",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 22,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 23,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "For destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 24,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "How can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 25,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    }
  ],
  "all_presentation_text_combined": "=== SLIDE 1 ===\nSemantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5\n\n=== SLIDE 2 ===\nSemantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code\n\n=== SLIDE 3 ===\nOutline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking\n\n=== SLIDE 4 ===\n5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?\n\n=== SLIDE 5 ===\nSymbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}\n\n=== SLIDE 6 ===\nSymbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1\n\n=== SLIDE 7 ===\nSymbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack\n\n=== SLIDE 8 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}.\n\n=== SLIDE 9 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table.\n\n=== SLIDE 10 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>\n\n=== SLIDE 11 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 12 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 13 ===\nEffective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>\n\n=== SLIDE 14 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?\n\n=== SLIDE 15 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX\n\n=== SLIDE 16 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large\n\n=== SLIDE 17 ===\nEfficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2\n\n=== SLIDE 18 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 19 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 20 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)\n\n=== SLIDE 21 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);\n\n=== SLIDE 22 ===\nThe Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}\n\n=== SLIDE 23 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}\n\n=== SLIDE 24 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}\n\n=== SLIDE 25 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.\n\n=== SLIDE 26 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}\n"
}
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

Here's a summary of the key points from the `Compile.pptx` presentation and the `HW.PDF` assignment, structured as requested in your `NOTE.md` file.

---

### NOTE.md

# Compiler Principles - Lecture Notes: Symbol Tables and Homework

## 1. Functional vs. Imperative Symbol Tables

Symbol tables (also called environments) are crucial during the semantic analysis phase of a compiler. They map identifiers to their types and locations, facilitating identifier declarations and lookups.

There are two primary styles for implementing symbol tables: Functional and Imperative.

### Functional Style Symbol Tables

*   **Definition:** In the functional style, when a new binding is added or an existing one is updated, the original symbol table remains unchanged. Instead, a *new* symbol table is created that incorporates the new binding, while the previous version is still available. This makes it easy to restore previous states, as old versions are preserved in their "pristine condition."
*   **Insertion Operation Differences:**
    *   When `Ïƒ' = Ïƒ + \{a â†¦ Ï„\}` is computed (where `a` is bound to type `Ï„` in a new environment `Ïƒ'`), `Ïƒ` is *not modified*.
    *   This style aims to avoid destructive updates.
    *   Achieving this efficiently with hash tables can be problematic because adding a new binding might require copying large parts of the hash table array if collisions occur, which is inefficient.
    *   Binary search trees are better suited for functional additions, as adding a new node at depth `d` only requires creating `d` new nodes along the path from the root, rather than copying the entire tree. This allows old versions of the tree to remain accessible.

### Imperative Style Symbol Tables

*   **Definition:** In the imperative style, symbol tables are directly modified (destructive updates). When a new binding is added, the existing table is changed. While a modified version exists, the previous state is not directly accessible without explicit undo mechanisms. To manage scopes and revert changes, this style typically uses a single global environment combined with an "undo stack."
*   **Insertion Operation Differences:**
    *   When `Ïƒ' = Ïƒ + \{a â†¦ Ï„\}` is computed, `Ïƒ` is *directly modified* to become `Ïƒ'`.
    *   If a key (`a`) already exists in the table with a binding (`Ï„1`), inserting a new binding (`Ï„2`) for the same key will typically place the new binding earlier in the collision chain (e.g., in a hash table with external chaining). This means the new binding `a â†¦ Ï„2` effectively "shadows" the old `a â†¦ Ï„1`.
    *   To restore the table to a previous state (e.g., when exiting a scope), explicit `pop` operations are used to remove bindings from the top of the stack within each hash bucket until a scope marker is found. This undoes modifications to get the original `Ïƒ` back.

---

## 2. Code Examples and Explanations for Symbol Table Operations

The presentation provides C code snippets illustrating the implementation of an imperative symbol table, particularly focusing on a hash table with external chaining and scope management.

### Imperative Symbol Table Core Structures and Hashing (Slides 11, 18)

```c
struct bucket \{ string key; void *binding; struct bucket *next; \};
#define SIZE 109
struct bucket *table[SIZE];

unsigned int hash(char *s0)
\{ unsigned int h=0; char *s;
  for(s=s0; *s; s++)
    h=h*65599 + *s; 
  return h; 
\}

struct bucket *Bucket (string key, void *binding, struct bucket *next) \{
  struct bucket *b=checked_malloc(sizeof(*b));
  b->key = key; b->binding = binding; b->next = next;
  return b; 
\}
```

*   **`struct bucket`**: This structure defines a node in the linked list used for collision resolution in the hash table. Each `bucket` stores:
    *   `key`: The identifier (e.g., variable name) as a string.
    *   `binding`: A pointer to the "meaning" of the identifier (e.g., its type, memory location). `void *` allows it to store any type of binding.
    *   `next`: A pointer to the next `bucket` in the linked list at the same hash table index, handling collisions.
*   **`#define SIZE 109`**: Defines the size of the hash table array. `109` is a prime number, often chosen to help distribute hash values more evenly and reduce collisions.
*   **`struct bucket *table[SIZE]`**: This is the actual hash table array. Each element `table[index]` is a pointer to the head of a linked list of `bucket` structures.
*   **`hash(char *s0)`**: This function computes a hash value for a given string `s0`. It uses a polynomial rolling hash algorithm (`h=h*65599 + *s`) to generate an unsigned integer. This hash value will then be used to determine the index in the `table` array where the `key` should be stored or looked up.
*   **`Bucket(string key, void *binding, struct bucket *next)`**: A utility function to create and initialize a new `bucket` node. It allocates memory using `checked_malloc` (a safe malloc variant), sets the `key`, `binding`, and `next` pointer, and returns a pointer to the newly created bucket.

### Imperative Symbol Table Operations (Slides 12, 19)

```c
void insert(string key, void *binding) \{
  int index=hash(key)%SIZE;
  table[index]=Bucket(key, binding, table[index]); 
\}

void *lookup(string key) \{
  int index=hash(key)%SIZE; 
  struct bucket *b;
  for (b = table[index]; b; b=b->next) 
    if (0==strcmp(b->key,key)) 
      return b->binding; 
  return NULL; 
\}

void pop(string key) \{ 
  int index=hash(key)%SIZE;
  table[index]=table[index]->next; 
\}
```

*   **`insert(string key, void *binding)`**: This function adds a new key-binding pair to the symbol table.
    1.  It calculates the `index` in the hash `table` using the `hash` function and the modulo operator (`% SIZE`).
    2.  It then creates a new `bucket` using `Bucket()`. Crucially, the `next` pointer of this new bucket is set to the *current* head of the linked list at `table[index]`.
    3.  Finally, `table[index]` is updated to point to this *newly created bucket*. This effectively "pushes" the new binding onto the front of the linked list, making it the most recently added binding for that hash index. This implements the shadowing behavior where newer bindings for the same key are found first.
*   **`lookup(string key)`**: This function searches for the `binding` associated with a given `key`.
    1.  It calculates the `index` for the `key`.
    2.  It then iterates through the linked list starting from `table[index]`.
    3.  For each `bucket` `b` in the list, it compares `b->key` with the target `key` using `strcmp`.
    4.  If a match is found, it immediately returns `b->binding` (which will be the most recently inserted binding due to the `insert` logic).
    5.  If the end of the list is reached without finding the `key`, it returns `NULL`.
*   **`pop(string key)`**: This function removes the most recently inserted binding for a given `key`.
    1.  It calculates the `index` for the `key`.
    2.  It then updates `table[index]` to point to `table[index]->next`. This effectively removes the head of the linked list at that index. In the context of scope management, this "pops" the most recent binding for `key` off the conceptual stack within that hash bucket, potentially revealing an older binding for the same key.

### Tiger Compiler Symbol and Symbol Table Interface (Slide 21)

```c
typedef struct S_symbol_ *S_symbol;
S_symbol S_symbol (string);
string S_name(S_symbol);

typedef struct TAB_table_ *S_table;
S_table S_empty( void);
void S_enter( S_table t,S_symbol sym, void *value); 
void *S_look( S_table t, S_symbol sym);
void S_beginScope( S_table t); 
void S_endScope( S_table t);
```

*   **`S_symbol`**: An opaque pointer type representing an interned string. This means that for every unique string literal in the program, there will be only one `S_symbol` object. This allows for very fast comparisons (`==` on pointers) instead of slow string comparisons (`strcmp`).
*   **`S_symbol S_symbol (string)`**: This function takes a string and returns its corresponding `S_symbol`. If the string has not been seen before, a new `S_symbol` is created and stored; otherwise, the existing `S_symbol` is returned.
*   **`string S_name(S_symbol)`**: Returns the original string name associated with an `S_symbol`.
*   **`S_table`**: An opaque pointer type representing the symbol table itself.
*   **`S_table S_empty(void)`**: Creates and returns an empty symbol table.
*   **`void S_enter(S_table t, S_symbol sym, void *value)`**: Enters a binding for an `S_symbol` (`sym`) with a `value` into the symbol table `t`.
*   **`void *S_look(S_table t, S_symbol sym)`**: Looks up the `value` associated with an `S_symbol` (`sym`) in table `t`.
*   **`void S_beginScope(S_table t)`**: Marks the beginning of a new scope in the symbol table `t`. All subsequent bindings until `S_endScope` are considered part of this scope.
*   **`void S_endScope(S_table t)`**: Exits the current scope in symbol table `t`, effectively removing all bindings that were introduced since the last `S_beginScope`.

### Implementation of Symbols (Slide 22)

```c
static S_symbol mksymbol (string name , S_symbol next) \{
  S_symbol s = checked_malloc(sizeof(*s));
  s->name = name; s->next = next;
  return s;
\}

S_symbol S_symbol (string name) \{
  int index = hash(name)%SIZE;
  S_symbol syms = hashtable[index], sym;
  for ( sym = syms; sym; sym = sym->next)
    if (0 == strcmp(sym->name, name)) return sym;
  sym = mksymbol(name,syms);
  hashtable[index] = sym;
   return sym;
\}

string S_name (S_symbol sym) \{
  return sym->name;
\}
```

*   **`mksymbol(string name, S_symbol next)`**: A private helper function to allocate and initialize an `S_symbol` structure. It sets its `name` and `next` pointer (used for collision chaining within the symbol interning hash table).
*   **`S_symbol (string name)`**: This is the symbol interning function.
    1.  It calculates a hash `index` for the input `name`.
    2.  It then searches the linked list at `hashtable[index]` to see if an `S_symbol` with the given `name` already exists.
    3.  If found, it returns the existing `S_symbol` (pointer).
    4.  If not found, it creates a new `S_symbol` using `mksymbol`, adds it to the head of the linked list at `hashtable[index]`, and returns the newly created `S_symbol`. This ensures that each unique string maps to a single, unique `S_symbol` object.
*   **`S_name (S_symbol sym)`**: A simple getter function that returns the original string `name` stored within the `S_symbol` structure.

### Implementation of Symbol Tables (Delegation and Scope Management) (Slides 23, 24)

```c
// make a new S_Table
S_table S_empty(void) \{
  return TAB_empty(); 
\}
// insert a binding
void S_enter(S_table t, S_symbol sym, void *value)\{ 
  TAB_enter(t,sym,value);
\} 
// look up a symbol
void *S_look(S_table t, S_symbol sym) \{ 
  return TAB_look(t,sym); 
\}

static struct S_symbol_ marksym = \{ "<mark>", 0 \};

void S_beginScope ( S_table t) \{ 
  S_enter(t, &marksym, NULL); 
\}

void S_endScope( S_table t) \{
  S_symbol s;
  do 
    s= TAB_pop(t); 
  while (s != &marksym);
\}
```

*   **Delegation to `TAB` module**: The `S_empty`, `S_enter`, and `S_look` functions in the `S_table` interface are implemented by directly calling corresponding functions in a generic `TAB` (Table) module. This means the `TAB` module provides the core imperative hash table functionality, and `S_table` leverages it for symbol management.
*   **`marksym`**: A special static `S_symbol` (`"<mark>"`) used as a sentinel to mark the beginning of a scope. Its address is unique and can be compared directly.
*   **`S_beginScope(S_table t)`**: To start a new scope, this function "enters" the special `marksym` into the symbol table `t` with a `NULL` binding. Because `S_enter` (and underlying `TAB_enter`) adds bindings in a stack-like manner, this `marksym` will be at the top of the stack for its hash bucket, serving as a boundary for the current scope.
*   **`S_endScope(S_table t)`**: To end the current scope, this function repeatedly calls `TAB_pop(t)` (which removes the most recently added binding from the table and returns the `S_symbol` that was unbound) until it encounters the `marksym`. This effectively "unwinds" or discards all bindings that were introduced within the current scope, restoring the table to its state before `S_beginScope` was called.

### Auxiliary Stack Integration (Slide 26)

```c
struct TAB_table_ \{
  binder table[TABSIZE];
  void *top;
\};

t->table[index] = Binder(key, value,t->table[index], t->top);

static binder Binder(void *key, void *value, binder next, void *prevtop) \{
  binder b = checked_malloc(sizeof(*b));
  b->key = key; b->value=value; b->next=next; 
  b->prevtop = prevtop;
  return b;
\}
```

*   **`struct TAB_table_`**: This reveals the internal structure of the generic imperative hash table.
    *   `binder table[TABSIZE]`: This is the array of hash table buckets, where each element is a `binder` (which is likely a pointer to a `binder` structure).
    *   `void *top`: This is a pointer that acts as the head of a *global auxiliary stack*. It points to the most recently added `binder` in the entire table, regardless of its hash bucket.
*   **`t->table[index] = Binder(key, value,t->table[index], t->top)`**: This line, likely part of `TAB_enter`, shows how a new `binder` is created and linked.
    *   The `next` field of the new `binder` points to the *previous* `binder` at the head of the current hash bucket's linked list (for collision chaining).
    *   The `prevtop` field of the new `binder` points to the *previous value of `t->top`*. This creates a linked list of all `binder`s in the order they were inserted, forming the global auxiliary stack. After creating the new `binder`, `t->top` would be updated to point to this new `binder`.
*   **`static binder Binder(void *key, void *value, binder next, void *prevtop)`**: This helper function creates and initializes a `binder` structure. The `prevtop` field is crucial for the auxiliary stack; it stores a pointer to the `binder` that was at the `top` of the global stack *before* the current `binder` was added. This allows `TAB_pop` (and thus `S_endScope`) to efficiently traverse and undo bindings in reverse insertion order.

---

## 3. Homework Assignments from `HW.PDF`
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
{
	"pdf_file_path":"HW.pdf"
}

```

```json output_result
PDF total pages: 2
Extracted page range: 1-1

=== Page 1 ===
Compiler Principles Assignment: Semantic Analysis & Symbol Tables  
Â 
Instructions:  Based on Chapter 5 of the "Modern Compiler Implementation" presentation, please answer the  
following questions. All questions are multiple-choice or fill-in-the-blank with a single correct answer.
Question 1 (Multiple Choice)
During the semantic analysis phase, the Symbol Table is crucial. When the compiler exits a scope (e.g., after a  
function body or a let block), it must restore the symbol table to its state before entering that scope. Which  
of the following implementation methods accomplishes this "restore" operation where the primary overhead  
involves manipulating a few pointers, rather than performing a large-scale copy of the entire data structure?
A) Making a complete, deep copy of the hash-table-based symbol table upon entering the scope.
B) Using a functional-style balanced binary search tree, which only creates new nodes along the path from the  
root to the insertion point when adding a new binding.
C) Using an imperative-style hash table combined with a separate "undo stack" to log all modifications, which  
are then reversed upon exiting the scope.
D) Both B and C are correct.
Question 2 (Fill in the Blank)
In the Tiger pseudocode below, assume the initial symbol table is Ïƒ0 = {g â†¦  string, a â†¦  int}. What is the  
type bound to the variable a when the print(a) statement on line 8 is executed?
Answer:  ____
Question 3 (Multiple Choice)
When implementing an imperative-style symbol table using a hash table with external chaining to resolve  
collisions, what is the most efficient and scope-compliant way to handle the insertion of a new binding a â†¦ 
Ï„2 when an older binding a â†¦ Ï„1 for the same identifier a already exists within the table?1 function f(a:int, b:int, c:int) =
2 (
3 Â  print_int(a+c);
4 Â  let 
5 Â  Â  var j := a+b
6 Â  Â  var a := "hello"
7 Â  in 
8 Â  Â  print(a); 
9 Â  Â  print_int(j)
10  end;
11  print_int(b)
12 )1
2
3
4
5
6
7
8
9
10
11
12

```

</Expandable>
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
{
	"end_page":2,
	"start_page":2,
	"pdf_file_path":"HW.pdf"
}

```

```json output_result
PDF total pages: 2
Extracted page range: 2-2

=== Page 2 ===
A) Traverse the collision chain to find and overwrite the old binding a â†¦  Ï„ 1.
B) Append the new binding a â†¦  Ï„ 2 to the end of the collision chain.
C) Insert the new binding a â†¦  Ï„ 2 at the head of the collision chain, effectively shadowing the old binding.
D) Throw a "variable redefined" compilation error.
Question 4 (Fill in the Blank)
To improve the efficiency of symbol table operations, particularly the cost of string lookups and comparisons,  
the Tiger compiler employs an optimization. It converts string identifiers into a unique, fixed-size data type. All  
subsequent hash calculations and equality checks are performed on this new type, avoiding repeated,  
character-by-character operations on the original strings. This optimized data type is referred to in the  
presentation as a ____.
Answer:  ____
Question 5 (Multiple Choice)
When processing a language like Java that allows forward references, a member of one class can reference a  
member of another class that is defined later in the source code. How is this typically handled by the symbol  
table system to ensure all symbols are visible when needed?
A) A single, global symbol table is used, and all members from all classes are placed directly into it.
B) Each class (E, N, D) has its own symbol table, which are then combined (e.g., Ïƒ 2 + Ïƒ 4 + Ïƒ 6) into a single,  
comprehensive environment Ïƒ 7 representing the entire package. This combined environment is then used for  
compiling the classes within it.
C) The compiler processes declarations in strict sequential order, so when compiling D, it can only see symbols  
from E and N if they have already been fully analyzed.
D) A stack-based symbol table is used, pushing a class's table onto the stack when entering it and popping it off  
when exiting.
Â 
Â // package M;
class E { static int a = 5; }
class N { static int b = 10; static int a = E.a + b; }
class D { static int d = E.a + N.a; }1
2
3
4

```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

The homework assignment `HW.PDF` covers the concepts discussed in the `Compile.pptx` presentation, focusing on semantic analysis and symbol tables. Here's a breakdown of each question:

**Question 1 (Multiple Choice)**

*   **Topic:** Restoring symbol table state after exiting a scope with minimal overhead.
*   **Context from Presentation:** Slide 7 discusses "Functional Style" (keeping pristine copies) and "Imperative Style" (modifying and using an undo stack). Slides 16 and 17 discuss functional style with binary search trees, noting that only `d` new nodes are created for an insertion at depth `d`. Slides 24, 25, and 26 detail the imperative style with an auxiliary stack and `marksym` for `beginScope` and `endScope`.
*   **Analysis:**
    *   A) Deep copying a hash table is inefficient for large programs.
    *   B) Functional-style balanced binary search trees are efficient for creating new versions while preserving old ones, as only a logarithmic number of nodes are copied/created.
    *   C) Imperative-style hash tables with an undo stack (like the `marksym` and `TAB_pop` mechanism) manipulate pointers to revert changes, which is also efficient.
    *   D) Both B and C describe efficient methods for restoring state without large-scale data copying.
*   **Answer:** D) Both B and C are correct.

**Question 2 (Fill in the Blank)**

*   **Topic:** Scope and shadowing in imperative symbol tables.
*   **Context from Presentation:** Slides 4, 5, and 6 illustrate how bindings are added and discarded in different scopes within a function. Specifically, `Ïƒ3 = Ïƒ2 + \{a â†¦ string\}` on line 4 shows `a` being rebound within a `let` block.
*   **Code Snippet:**
    ```
    1 function f(a:int, b:int, c:int) =
    2 (
    3   print_int(a+c);
    4   let
    5     var j := a+b
    6     var a := "hello"
    7   in
    8     print(a);
    9     print_int(j)
    10  end;
    11  print_int(b)
    12 )
    ```
*   **Analysis:**
    *   Initial scope: `Ïƒ0 = \{g â†¦ string, a â†¦ int\}`.
    *   Line 1 (function `f` parameters): `Ïƒ1 = Ïƒ0 + \{a â†¦ int, b â†¦ int, c â†¦ int\}`.
    *   Line 5 (`let var j := a+b`): `Ïƒ2 = Ïƒ1 + \{j â†¦ int\}`. At this point, `a` is `int`.
    *   Line 6 (`var a := "hello"`): A new `a` is declared within the `let` block. `Ïƒ3 = Ïƒ2 + \{a â†¦ string\}`. This new `a` (string type) *shadows* the outer `a` (int type).
    *   Line 8 (`print(a)`): This statement is executed within the scope where `a` was declared as `"hello"`.
*   **Answer:** string

**Question 3 (Multiple Choice)**

*   **Topic:** Efficient insertion in imperative hash tables with external chaining and scope compliance.
*   **Context from Presentation:** Slide 13 explicitly states: "The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. hash(a) -> <a, Ï„2 > -> <a, Ï„1>". This is further supported by the `insert` function on Slide 12/19: `table[index]=Bucket(key, binding, table[index]);`, which prepends the new binding.
*   **Analysis:**
    *   A) Overwriting the old binding would mean losing information about the outer scope's binding, which is incorrect for nested scopes.
    *   B) Appending to the end would mean the old binding is found first, which prevents shadowing.
    *   C) Inserting at the head of the collision chain ensures that the *newest* binding for `a` is found first during a `lookup`, effectively shadowing older bindings within the current scope. When the scope ends, this new binding can be easily popped, revealing the previous one.
    *   D) While some languages might throw an error for redefinition in the same scope, in languages with nested scopes (like Tiger), shadowing is a common and expected behavior.
*   **Answer:** C) Insert the new binding a â†¦ Ï„2 at the head of the collision chain, effectively shadowing the old binding.

**Question 4 (Fill in the Blank)**

*   **Topic:** Optimization for string identifiers in symbol tables.
*   **Context from Presentation:** Slide 20 discusses improving efficiency by converting each string to a "symbol." It states: "Convert each string to a symbol. The Symbol module has these important properties: Extracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables) Comparing symbols for equality is fast (just pointer or integer comparison)."
*   **Answer:** Symbol

**Question 5 (Multiple Choice)**

*   **Topic:** Handling multiple active environments and forward references (e.g., in Java).
*   **Context from Presentation:** Slides 7, 8, and 9 discuss "Multiple Symbol Tables." Slide 8 specifically mentions Java and forward references: "In Java, forward reference is allowed. so E, N, and D are all compiled in the environment Ïƒ7. The result of the analysis is \{M â†¦ Ïƒ 7\}." It then shows `Ïƒ7 = Ïƒ2 + Ïƒ4 + Ïƒ6`, where `Ïƒ2 = \{E â†¦ Ïƒ1\}`, `Ïƒ4 = \{N â†¦ Ïƒ3\}`, and `Ïƒ6 = \{D â†¦ Ïƒ5\}`. This implies that individual class symbol tables are combined.
*   **Analysis:**
    *   A) A single, flat global symbol table would lose the hierarchical structure and scope information of classes/modules.
    *   B) This aligns perfectly with the explanation for Java on Slide 8. Each class gets its own symbol table, and these are then combined into a comprehensive environment for the entire package, allowing all symbols to be visible for forward references.
    *   C) Strict sequential processing would prevent forward references.
    *   D) While stack-based symbol tables are used for nested *scopes within a function*, for separate classes/modules that can reference each other, a combined environment is more appropriate.
*   **Answer:** B) Each class (E, N, D) has its own symbol table, which are then combined (e.g., Ïƒ2 + Ïƒ4 + Ïƒ6) into a single, comprehensive environment Ïƒ7 representing the entire package. This combined environment is then used for compiling the classes within it.

---
</div>

</Accordion>

<Accordion title="gpt-5">

<Columns cols={3}>
<Card title="Task Completion" icon="x">
Failed
</Card>
<Card title="Tool Calls" icon="wrench">
7
</Card>
<Card title="Turns" icon="arrows-rotate">
8
</Card>
</Columns>

<div className="result-box">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48" width="14px" height="14px" style={{margin: 0, padding: 0, display: 'inline-block'}}><path fill="#FFA000" d="M40,12H22l-4-4H8c-2.2,0-4,1.8-4,4v8h40v-4C44,13.8,42.2,12,40,12z"/><path fill="#FFCA28" d="M40,12H8c-2.2,0-4,1.8-4,4v20c0,2.2,1.8,4,4,4h32c2.2,0,4-1.8,4-4V16C44,13.8,42.2,12,40,12z"/></svg> `filesystem list_allowed_directories`

<Expandable title="Details">
```json arguments
{}

```

```json output_result
Allowed directories:
/workspace/dumps/workspace
```

</Expandable>
</div>

<div className="result-box">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48" width="14px" height="14px" style={{margin: 0, padding: 0, display: 'inline-block'}}><path fill="#FFA000" d="M40,12H22l-4-4H8c-2.2,0-4,1.8-4,4v8h40v-4C44,13.8,42.2,12,40,12z"/><path fill="#FFCA28" d="M40,12H8c-2.2,0-4,1.8-4,4v20c0,2.2,1.8,4,4,4h32c2.2,0,4-1.8,4-4V16C44,13.8,42.2,12,40,12z"/></svg> `filesystem list_directory`

<Expandable title="Details">
```json arguments
{
	"path":"/workspace/dumps/workspace"
}

```

```json output_result
[DIR] .pdf_tools_tempfiles
[FILE] Compile.pptx
[FILE] HW.pdf
```

</Expandable>
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx open_presentation`

<Expandable title="Details">
```json arguments
{
	"file_path":"/workspace/dumps/workspace/Compile.pptx",
	"id":null
}

```

```json output_result
{
  "presentation_id": "presentation_1",
  "message": "Opened presentation from /workspace/dumps/workspace/Compile.pptx with ID: presentation_1",
  "slide_count": 26
}
```

</Expandable>
</div>

<div className="result-box">
<svg viewBox="-0.12979372698077785 0 32.152389301176754 32" xmlns="http://www.w3.org/2000/svg" width="14" height="14" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M18 2A14.041 14.041 0 0 0 4 16l17.737 3.737z" fill="#ed6c47"/><path d="M18 2a14.041 14.041 0 0 1 14 14l-7 4.758L18 16z" fill="#ff8f6b"/><path d="M18 30a14.041 14.041 0 0 0 14-14H4a14.041 14.041 0 0 0 14 14z" fill="#d35230"/><path d="M16.666 7h-9.36a13.914 13.914 0 0 0 .93 19h8.43A1.337 1.337 0 0 0 18 24.667V8.333A1.337 1.337 0 0 0 16.666 7z" opacity=".1"/><path d="M15.666 8H6.54a13.906 13.906 0 0 0 2.845 19h6.282A1.337 1.337 0 0 0 17 25.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M15.666 8H6.54a13.89 13.89 0 0 0 .766 17h8.361A1.337 1.337 0 0 0 17 23.667V9.333A1.337 1.337 0 0 0 15.666 8z" opacity=".2"/><path d="M14.666 8H6.54a13.89 13.89 0 0 0 .766 17h7.361A1.337 1.337 0 0 0 16 23.667V9.333A1.337 1.337 0 0 0 14.666 8z" opacity=".2"/><path d="M1.333 8h13.334A1.333 1.333 0 0 1 16 9.333v13.334A1.333 1.333 0 0 1 14.667 24H1.333A1.333 1.333 0 0 1 0 22.667V9.333A1.333 1.333 0 0 1 1.333 8z" fill="#c43e1c"/><path d="M7.997 11a4.168 4.168 0 0 1 2.755.805 2.878 2.878 0 0 1 .956 2.331 2.726 2.726 0 0 1-.473 1.588 3.164 3.164 0 0 1-1.344 1.186 4.57 4.57 0 0 1-2.02.424h-1.91V21H4V11zM5.96 15.683h1.687a2.194 2.194 0 0 0 1.492-.444 1.107 1.107 0 0 0 .504-1.026q0-1.659-1.933-1.659H5.96z" fill="#f9f7f7"/><path d="M0 0h32v32H0z" fill="none"/></svg> `pptx extract_presentation_text`

<Expandable title="Details">
```json arguments
{
	"presentation_id":"presentation_1",
	"include_slide_info":true
}

```

```json output_result
{
  "success": true,
  "presentation_id": "presentation_1",
  "total_slides": 26,
  "slides_with_text": 26,
  "total_text_shapes": 45,
  "slides_with_titles": 26,
  "slides_with_tables": 2,
  "slides_text": [
    {
      "slide_index": 0,
      "text_content": {
        "slide_title": "Semantic Analysis\u000bChapter 5",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis\u000bChapter 5",
            "placeholder_type": "CENTER_TITLE (3)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5"
      },
      "layout_name": "æ ‡é¢˜å¹»ç¯ç‰‡",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 1,
      "text_content": {
        "slide_title": "Semantic Analysis",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Semantic Analysis",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Semantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 2,
      "text_content": {
        "slide_title": "Outline",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Outline",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables\nBindings for the Tiger Compiler\nType Checking",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Outline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 3,
      "text_content": {
        "slide_title": "5.1 Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "5.1 Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 4,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "ï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 5,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Each local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 6,
      "text_content": {
        "slide_title": "Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 7,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 8,
      "text_content": {
        "slide_title": "Multiple Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Multiple Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Multiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 9,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Imperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 10,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 11,
      "text_content": {
        "slide_title": "Efficient Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 12,
      "text_content": {
        "slide_title": "Effective Imperative Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Effective Imperative Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Consider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Effective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 13,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Functional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 14,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 15,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "m2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Efficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 16,
      "text_content": {
        "slide_title": "Efficient Functional Symbol Table",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Efficient Functional Symbol Table",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "We can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [
          {
            "shape_index": 3,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          },
          {
            "shape_index": 5,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "bat",
                  "1"
                ]
              }
            ]
          },
          {
            "shape_index": 6,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "camel",
                  "2"
                ]
              }
            ]
          },
          {
            "shape_index": 9,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "mouse",
                  "4"
                ]
              }
            ]
          },
          {
            "shape_index": 11,
            "shape_name": "è¡¨æ ¼ 27",
            "table_content": [
              {
                "row": 0,
                "cells": [
                  "dog",
                  "3"
                ]
              }
            ]
          }
        ],
        "all_text_combined": "Efficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": true
    },
    {
      "slide_index": 17,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 18,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 19,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "In Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 20,
      "text_content": {
        "slide_title": "Symbols in The Tiger Compiler",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "Symbols in The Tiger Compiler",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "Symbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 21,
      "text_content": {
        "slide_title": "The Implementation of Symbols",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbols",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 1,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 22,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 23,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "For destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 24,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "How can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker."
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    },
    {
      "slide_index": 25,
      "text_content": {
        "slide_title": "The Implementation of Symbol Tables",
        "placeholders": [
          {
            "shape_index": 0,
            "shape_name": "æ ‡é¢˜ 1",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The Implementation of Symbol Tables",
            "placeholder_type": "TITLE (1)",
            "placeholder_idx": 0
          },
          {
            "shape_index": 1,
            "shape_name": "å†…å®¹å ä½ç¬¦ 2",
            "shape_type": "PLACEHOLDER (14)",
            "text": "The auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.",
            "placeholder_type": "OBJECT (7)",
            "placeholder_idx": 1
          }
        ],
        "text_shapes": [],
        "table_text": [],
        "all_text_combined": "The Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}"
      },
      "layout_name": "æ ‡é¢˜å’Œå†…å®¹",
      "total_text_shapes": 2,
      "has_title": true,
      "has_tables": false
    }
  ],
  "all_presentation_text_combined": "=== SLIDE 1 ===\nSemantic Analysis\u000bChapter 5\nSemantic Analysis\u000bChapter 5\n\n=== SLIDE 2 ===\nSemantic Analysis\nSemantic Analysis\nThe semantic analysis phase of a compiler:\nconnects variable definitions to their uses\nchecks that each expression has a correct type\ntranslates the abstract syntax into a simpler representation suitable for generating machine code\n\n=== SLIDE 3 ===\nOutline\nOutline\nSymbol Tables\nBindings for the Tiger Compiler\nType Checking\n\n=== SLIDE 4 ===\n5.1 Symbol Tables\n5.1 Symbol Tables\nThe semantic analysis phase is characterized by the maintenance of symbol tables (also called environments) mapping identiï¬ers to their types and locations.\nDeclarations of identifiers: IDs are bound to â€œmeaningsâ€ in the symbol tables\nUses of identifiers: look up IDs in the symbol tables. \nAn environment is a set of bindings denoted by the â†¦ arrow.\nE.g., Ïƒ0 = {g â†¦ string, a â†¦ int}\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 1: ï³1 = ï³0 + {a â†¦ int, b â†¦ int, c â†¦ int}\nline 3: ï³2 = ï³1 + {j â†¦ int}\nline 4: ï³3 = ï³2 + {a â†¦ string}\nhow do the compiler know the type of j?\n\n=== SLIDE 5 ===\nSymbol Tables\nSymbol Tables\nï³2 contains a â†¦ int\nWhat is the binding of a in ï³3?\nBindings in the right-hand table override those in the left.\nX + Y for tables is not the same as Y + X.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 4: ï³3 = ï³2 + {a â†¦ string}\n\n=== SLIDE 6 ===\nSymbol Tables\nSymbol Tables\nEach local variable in a program has a scope in which it is visible.\nAs the semantic analysis reaches the end of each scope, the identiï¬er bindings local to that scope are discarded.\n1 function f(a:int,b:int,c:int)=\n2\t(print_int (a+c);\n3\tlet var j:= a+b\n4\t\t var a:= â€œhelloâ€\n5\t in print(a); print_int(j)\n6\tend;\n7\tprint_int(b)\n8\t)\nline 6: discard ï³3, go back to ï³1 (line 1)\nline 8: discard ï³1, go back to ï³0\nSymbol table: add/lookup/undo bindings\nHow should symbol tables be implemented?\nline 7: look up b in ï³1\n\n=== SLIDE 7 ===\nSymbol Tables\nSymbol Tables\nFunctional Style\nKeep ï³1 in pristine condition while creating ï³2 and ï³3\nEasy to restore ï³1 \n\nImperative Style\nmodify ï³1 until it becomes ï³2\nwhile ï³2 exists, we cannot look things up in ï³1\nwhen we are done with ï³2, we can undo the modification to get ï³1 back again\nHow?\na single global environment ï³ + an undo stack\n\n=== SLIDE 8 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nIn some languages there can be several active environments at once: Each module, or class, or record in the program has a symbol table ï³ of its own.\npackage M; Â Â \nclass E { Â Â \n     static int a = 5; Â Â \n} Â \nclass N { Â Â \n     static int b = 10; Â Â \n     static int a = E.a + b; Â \nÂ } Â Â \nclass D { Â Â \n     static int d = E.a + N.a; Â \nÂ }\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nJava\nIn Java, forward reference is allowed. so E, N, and D are all compiled in the environment ï³7. The result of the analysis is {M â†¦ ï³ 7}.\n\n=== SLIDE 9 ===\nMultiple Symbol Tables\nMultiple Symbol Tables\nstructure M = struct \n   structure E = struct \n      val a = 5; \n   end \n   structure N = struct \n      val b = 10 \n      val a = E.a + b \n   end \n   structure D = struct \n      val d = E.a + N.a \n   end \nend\nML\nN is compiled using environment ï³0 + ï³2. D is compiled using ï³ 0 + ï³2 + ï³4.  \nThe result of the analysis is also {M â†¦ ï³ 7}.\nï³1 = { a â†¦ int }\nï³2 = { E â†¦ ï³1 }\nï³3= {b â†¦ int , a â†¦ int }\nï³4= { N â†¦ ï³3 }\nï³5= { d â†¦ int }\nï³6= { D â†¦ ï³5 }\nï³7 = ï³2 +ï³4+ ï³6\nEach class/structure has its own symbol table.\n\n=== SLIDE 10 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nImperative Style\nBecause a large program may contain thousands of distinct identiï¬ers, symbol tables must permit efï¬cient lookup.\nHow?\nHash Table\nï³â€™ = ï³ + {a â†¦ int}\ninsert <a, int> in the hash table\nSymbol tables need to support deletion easily.\nHow?\nHash Table with external chaining\ne.g., hash(a) -> <a, int> -> <a, string>\n\n=== SLIDE 11 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; \n}\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 12 ===\nEfficient Imperative Symbol Tables\nEfficient Imperative Symbol Tables\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 13 ===\nEffective Imperative Symbol Tables\nEffective Imperative Symbol Tables\nConsider ï³ + {a â†¦ Ï„2} when ï³ contains a â†¦ Ï„1 already.\n\n The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. \nhash(a) -> <a, Ï„2 > -> <a, Ï„1>\n\nwhen pop(a) is done at the end of a's scope, ï³ is restored. (insertion and pop work in a stack-like fashion.)\nhash(a) -> <a, Ï„1>\n\n=== SLIDE 14 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nFunctional Style\nWe wish to compute ï³â€² = ï³ + {a â†¦ Ï„} in such a way that we still have ï³ available to look up identifiers. \ndo not change ï³\n\nWe create a new table by computing the \"sum\" of an existing table and a new binding.\n\nCan we achieve this with hash tables?\n\n=== SLIDE 15 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nmouse\n4\nX\n\n=== SLIDE 16 ===\nEfficient Functional Symbol Tables\nEfficient Functional Symbol Tables\nm2 = m1 + {mouse â†¦ 4}\nm1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5\nHash(mouse) -> <mouse, 4>: no longer have m1\nCopy the array, but share all the old buckets: not efficient\nThe array in a hash table should be quite large\n\n=== SLIDE 17 ===\nEfficient Functional Symbol Table\nEfficient Functional Symbol Table\nWe can perform such â€œfunctionalâ€ additions to search trees efï¬ciently by using binary search trees.\nIf we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.\nCopy the nodes from the root to the parent of the inserted node.\n\nm1 keeps unchanged.\n\nLooking up an element: log(n) for a balanced tree of n nodes.\ndog\n3\nbat\n1\ncamel\n2\nmouse\n4\nm1\ndog\n3\nm2\n\n=== SLIDE 18 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nstruct bucket { string key; void *binding; struct bucket *next; };\n\u000b#define SIZE 109\n\u000bstruct bucket *table[SIZE];\n\u000bunsigned int hash(char *s0)\n{ unsigned int h=0; char *s;\n  for(s=s0; *s; s++)\n    h=h*65599 + *s; \n  return h; \n}\n\n\u000bstruct bucket *Bucket (string key, void *binding, struct bucket *next) {\n  struct bucket *b=checked_malloc(sizeof(*b));\n  b->key = key; b->binding = binding; b->next = next;\n  return b; }\nh = (ï¡n-1c1+ï¡n-2c2 +â€¦..+ ï¡ cn-1+ cn)\n\n=== SLIDE 19 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nvoid insert(string key, void *binding) {\n  int index=hash(key)%SIZE;\n  table[index]=Bucket(key, binding, table[index]); \n}\n\u000bvoid *lookup(string key) {\n  int index=hash(key)%SIZE \n  struct bucket *b;\n  for (b = table[index]; b; b=b->next) \n    if (0==strcmp(b->key,key)) \n      return b->binding; \n  return NULL; \n}\n\u000bvoid pop(string key) { \n  int index=hash(key)%SIZE\n  table[index]=table[index].next; \n}\n\n=== SLIDE 20 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nIn Program 5.2: \nmust examine every character of the string s for the hash operation\neach time it compares s against a string in the ith bucket\nHow to improve?\nConvert each string to a symbol\nThe Symbol module has these important properties:\nExtracting an integer hash-key is very fast: use the Symbol-pointer itself as the integer hash-key. (for hash tables)\nComparing symbols for equality is fast (just pointer or integer comparison).\nComparing two symbols for â€œgreater-thanâ€ (in some arbitrary ordering) is very fast  (for binary search trees)\n\n=== SLIDE 21 ===\nSymbols in The Tiger Compiler\nSymbols in The Tiger Compiler\nThe interface of symbols and symbol tables\nvoid *: We want different notions of binding for different purposes in the compiler â€“ type bindings for types, value bindings for variables and functions\ntypedef struct S_symbol_ *S_symbol;\nS_symbol S_symbol (string);\nstring S_name(S_symbol);\n\u000btypedef struct TAB_table_ *S_table;\nS_table S_empty( void);\nvoid S_enter( S_table t,S_symbol sym, void *value); \nvoid *S_look( S_table t, S_symbol sym);\nvoid S_beginScope( S_table t); \nvoid S_endScope( S_table t);\n\n=== SLIDE 22 ===\nThe Implementation of Symbols\nThe Implementation of Symbols\nstatic S_symbol mksymbol (string name , S_symbol next) {\n  S_symbol s = checked_malloc(sizeof(*s));\n  s->name = name; s->next = next;\n  return s;\n}\n\u000bS_symbol S_symbol (string name) {\n\tint index = hash(name)%SIZE;\n\tS_symbol syms = hashtable[index], sym;\n\tfor ( sym = syms; sym; sym = sym->next)\n\t  if (0 == strcmp(sym->name, name)) return sym;\n\tsym = mksymbol(name,syms);\n\thashtable[index] = sym;\n   return sym;\n}\n\u000bstring S_name (S_symbol sym) {\n  return sym->name;\n}\n\n=== SLIDE 23 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe Tiger compiler in C uses destructive-update environments.\nAn imperative table is implemented using a hash table.\nTAB: a generic hash table module\n// make a new S_Table\nS_table S_empty(void) {\n  return TAB_empty(); \n}\n// insert a binding\nvoid S_enter(S_table t, S_symbol sym, void *value){ \n  TAB_enter(t,sym,value);\n} \n// look up a symbol\nvoid *S_look(S_table t, S_symbol sym) { \n  return TAB_look(t,sym); \n}\n\n=== SLIDE 24 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nFor destructive-update environments:\nS_beginScope: Remembers the current state of the table\nS_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.\nstatic struct S_symbol_ marksym = { â€œ<mark>â€, 0 };\n\u000bvoid S_beginScope ( S_table t) { \n  S_enter(t, &marksym, NULL); \n}\n\u000bvoid S_endScope( S_table t) {\n  S_symbol s;\n  do \n    s= TAB_pop(t); \n  while (s != &marksym);\n}\n\n=== SLIDE 25 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nHow can we exactly pop those bindings after enterScope?\n\nAuxiliary stack:\nShowing in what order the symbols  were â€œpushedâ€ into the symbol table. \nAs each symbol in this stack is popped, the head binding in its bucket is removed.\nbeginScope: pushes a special marker onto the stack\nendScope: pops symbols off the stack until finds the topmost marker.\n\n=== SLIDE 26 ===\nThe Implementation of Symbol Tables\nThe Implementation of Symbol Tables\nThe auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. \nPushing: copy top into the prevtop field of the Binder.\nstruct TAB_table_ {\n  binder table[TABSIZE];\n  void *top;\n};\n\nt->table[index] = Binder(key, value,t->table[index], t->top);\u000b\nstatic binder Binder(void *key, void *value, binder next, void *prevtop) {\n  binder b = checked_malloc(sizeof(*b));\n  b->key = key; b->value=value; b->next=next; \n  b->prevtop = prevtop;\n  return b;\n}\n"
}
```

</Expandable>
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools get_pdf_info`

<Expandable title="Details">
```json arguments
{
	"pdf_file_path":"/workspace/dumps/workspace/HW.pdf"
}

```

```json output_result
PDF file information:
Total pages: 2
Title: 
Author: 
Creator: Typora
Creation date: 20250707010226

```

</Expandable>
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
{
	"pdf_file_path":"/workspace/dumps/workspace/HW.pdf",
	"start_page":1,
	"end_page":2
}

```

```json output_result
PDF total pages: 2
Extracted page range: 1-2

=== Page 1 ===
Compiler Principles Assignment: Semantic Analysis & Symbol Tables  
Â 
Instructions:  Based on Chapter 5 of the "Modern Compiler Implementation" presentation, please answer the  
following questions. All questions are multiple-choice or fill-in-the-blank with a single correct answer.
Question 1 (Multiple Choice)
During the semantic analysis phase, the Symbol Table is crucial. When the compiler exits a scope (e.g., after a  
function body or a let block), it must restore the symbol table to its state before entering that scope. Which  
of the following implementation methods accomplishes this "restore" operation where the primary overhead  
involves manipulating a few pointers, rather than performing a large-scale copy of the entire data structure?
A) Making a complete, deep copy of the hash-table-based symbol table upon entering the scope.
B) Using a functional-style balanced binary search tree, which only creates new nodes along the path from the  
root to the insertion point when adding a new binding.
C) Using an imperative-style hash table combined with a separate "undo stack" to log all modifications, which  
are then reversed upon exiting the scope.
D) Both B and C are correct.
Question 2 (Fill in the Blank)
In the Tiger pseudocode below, assume the initial symbol table is Ïƒ0 = {g â†¦  string, a â†¦  int}. What is the  
type bound to the variable a when the print(a) statement on line 8 is executed?
Answer:  ____
Question 3 (Multiple Choice)
When implementing an imperative-style symbol table using a hash table with external chaining to resolve  
collisions, what is the most efficient and scope-compliant way to handle the insertion of a new binding a â†¦ 
Ï„2 when an older binding a â†¦ Ï„1 for the same identifier a already exists within the table?1 function f(a:int, b:int, c:int) =
2 (
3 Â  print_int(a+c);
4 Â  let 
5 Â  Â  var j := a+b
6 Â  Â  var a := "hello"
7 Â  in 
8 Â  Â  print(a); 
9 Â  Â  print_int(j)
10  end;
11  print_int(b)
12 )1
2
3
4
5
6
7
8
9
10
11
12


=== Page 2 ===
A) Traverse the collision chain to find and overwrite the old binding a â†¦  Ï„ 1.
B) Append the new binding a â†¦  Ï„ 2 to the end of the collision chain.
C) Insert the new binding a â†¦  Ï„ 2 at the head of the collision chain, effectively shadowing the old binding.
D) Throw a "variable redefined" compilation error.
Question 4 (Fill in the Blank)
To improve the efficiency of symbol table operations, particularly the cost of string lookups and comparisons,  
the Tiger compiler employs an optimization. It converts string identifiers into a unique, fixed-size data type. All  
subsequent hash calculations and equality checks are performed on this new type, avoiding repeated,  
character-by-character operations on the original strings. This optimized data type is referred to in the  
presentation as a ____.
Answer:  ____
Question 5 (Multiple Choice)
When processing a language like Java that allows forward references, a member of one class can reference a  
member of another class that is defined later in the source code. How is this typically handled by the symbol  
table system to ensure all symbols are visible when needed?
A) A single, global symbol table is used, and all members from all classes are placed directly into it.
B) Each class (E, N, D) has its own symbol table, which are then combined (e.g., Ïƒ 2 + Ïƒ 4 + Ïƒ 6) into a single,  
comprehensive environment Ïƒ 7 representing the entire package. This combined environment is then used for  
compiling the classes within it.
C) The compiler processes declarations in strict sequential order, so when compiling D, it can only see symbols  
from E and N if they have already been fully analyzed.
D) A stack-based symbol table is used, pushing a class's table onto the stack when entering it and popping it off  
when exiting.
Â 
Â // package M;
class E { static int a = 5; }
class N { static int b = 10; static int a = E.a + b; }
class D { static int d = E.a + N.a; }1
2
3
4

```

</Expandable>
</div>

<div className="result-box">
<svg width="14px" height="14px" viewBox="-4 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" style={{margin: 0, padding: 0, display: 'inline-block'}}><path d="M25.6686 26.0962C25.1812 26.2401 24.4656 26.2563 23.6984 26.145C22.875 26.0256 22.0351 25.7739 21.2096 25.403C22.6817 25.1888 23.8237 25.2548 24.8005 25.6009C25.0319 25.6829 25.412 25.9021 25.6686 26.0962ZM17.4552 24.7459C17.3953 24.7622 17.3363 24.7776 17.2776 24.7939C16.8815 24.9017 16.4961 25.0069 16.1247 25.1005L15.6239 25.2275C14.6165 25.4824 13.5865 25.7428 12.5692 26.0529C12.9558 25.1206 13.315 24.178 13.6667 23.2564C13.9271 22.5742 14.193 21.8773 14.468 21.1894C14.6075 21.4198 14.7531 21.6503 14.9046 21.8814C15.5948 22.9326 16.4624 23.9045 17.4552 24.7459ZM14.8927 14.2326C14.958 15.383 14.7098 16.4897 14.3457 17.5514C13.8972 16.2386 13.6882 14.7889 14.2489 13.6185C14.3927 13.3185 14.5105 13.1581 14.5869 13.0744C14.7049 13.2566 14.8601 13.6642 14.8927 14.2326ZM9.63347 28.8054C9.38148 29.2562 9.12426 29.6782 8.86063 30.0767C8.22442 31.0355 7.18393 32.0621 6.64941 32.0621C6.59681 32.0621 6.53316 32.0536 6.44015 31.9554C6.38028 31.8926 6.37069 31.8476 6.37359 31.7862C6.39161 31.4337 6.85867 30.8059 7.53527 30.2238C8.14939 29.6957 8.84352 29.2262 9.63347 28.8054ZM27.3706 26.1461C27.2889 24.9719 25.3123 24.2186 25.2928 24.2116C24.5287 23.9407 23.6986 23.8091 22.7552 23.8091C21.7453 23.8091 20.6565 23.9552 19.2582 24.2819C18.014 23.3999 16.9392 22.2957 16.1362 21.0733C15.7816 20.5332 15.4628 19.9941 15.1849 19.4675C15.8633 17.8454 16.4742 16.1013 16.3632 14.1479C16.2737 12.5816 15.5674 11.5295 14.6069 11.5295C13.948 11.5295 13.3807 12.0175 12.9194 12.9813C12.0965 14.6987 12.3128 16.8962 13.562 19.5184C13.1121 20.5751 12.6941 21.6706 12.2895 22.7311C11.7861 24.0498 11.2674 25.4103 10.6828 26.7045C9.04334 27.3532 7.69648 28.1399 6.57402 29.1057C5.8387 29.7373 4.95223 30.7028 4.90163 31.7107C4.87693 32.1854 5.03969 32.6207 5.37044 32.9695C5.72183 33.3398 6.16329 33.5348 6.6487 33.5354C8.25189 33.5354 9.79489 31.3327 10.0876 30.8909C10.6767 30.0029 11.2281 29.0124 11.7684 27.8699C13.1292 27.3781 14.5794 27.011 15.985 26.6562L16.4884 26.5283C16.8668 26.4321 17.2601 26.3257 17.6635 26.2153C18.0904 26.0999 18.5296 25.9802 18.976 25.8665C20.4193 26.7844 21.9714 27.3831 23.4851 27.6028C24.7601 27.7883 25.8924 27.6807 26.6589 27.2811C27.3486 26.9219 27.3866 26.3676 27.3706 26.1461ZM30.4755 36.2428C30.4755 38.3932 28.5802 38.5258 28.1978 38.5301H3.74486C1.60224 38.5301 1.47322 36.6218 1.46913 36.2428L1.46884 3.75642C1.46884 1.6039 3.36763 1.4734 3.74457 1.46908H20.263L20.2718 1.4778V7.92396C20.2718 9.21763 21.0539 11.6669 24.0158 11.6669H30.4203L30.4753 11.7218L30.4755 36.2428ZM28.9572 10.1976H24.0169C21.8749 10.1976 21.7453 8.29969 21.7424 7.92417V2.95307L28.9572 10.1976ZM31.9447 36.2428V11.1157L21.7424 0.871022V0.823357H21.6936L20.8742 0H3.74491C2.44954 0 0 0.785336 0 3.75711V36.2435C0 37.5427 0.782956 40 3.74491 40H28.2001C29.4952 39.9997 31.9447 39.2143 31.9447 36.2428Z" fill="#EB5757"/></svg> `pdf-tools read_pdf_pages`

<Expandable title="Details">
```json arguments
workspace/NOTE.md
# Notes: Semantic Analysis â€“ Symbol Tables (from Compile.pptx)

## 1) Definitions and insertion differences

- Imperative symbol table (destructive update)
  - Definition: A single mutable environment that is updated in place (typically a hash table with external chaining). Scope management is done by logging operations and later undoing them, so the same table structure is reused across scopes.
  - Insertion behavior: Directly modifies the table. For a new binding x â†¦ Ï„2 when x â†¦ Ï„1 already exists, the new binding is pushed at the head of the bucketâ€™s chain. This shadows the older binding and enables O(1) scope pop by removing the head.
  - Scope pop: Restore by popping from an auxiliary undo stack or by using a per-bucket stack discipline; pointer/stack manipulations onlyâ€”no wholesale copying.

- Functional symbol table (persistent/immutable)
  - Definition: Each update produces a new table value Ïƒâ€² = Ïƒ + {x â†¦ Ï„} while the old Ïƒ remains available. Implemented efficiently with persistent balanced binary search trees (BSTs) by copying only the nodes along the root-to-insert path (O(log n) nodes).
  - Insertion behavior: Does not mutate the original table; returns a new table that shares most of its structure with the old one. With arrays (e.g., classic hash table backing), a functional update would require copying the whole array, which is inefficient; hence trees are preferred for persistent maps.
  - Scope pop: Trivialâ€”discard the newer table reference and keep using the older one (since it was never modified).

Difference in insertion operations in one sentence:
- Imperative insertion mutates in place (push-at-head in the bucket chain to shadow previous bindings), while functional insertion returns a new table sharing structure (path-copying in a BST) and leaves the old table intact.

---

## 2) Original code from the slides with explanations

Below are the original code/text snippets as shown in the slides, grouped by topic, followed by concise explanations of their purpose and how they support different symbol-table modes.

### 2.1 Tiger example for scopes and shadowing

`*3
1 function f(a:int,b:int,c:int)=
2	(print_int (a+c);
3	let var j:= a+b
4		 var a:= â€œhelloâ€
5	 in print(a); print_int(j)
6	end;
7	print_int(b)
8	)
`*3

Explanation:
- Demonstrates environments Ïƒ0 â†’ Ïƒ1 â†’ Ïƒ2 â†’ Ïƒ3 as declarations are encountered.
- Line 4 introduces a new a bound to string that shadows the outer a:int inside the let-in block; line 8 prints the inner a (type string) within that scope.
- At the end of the let (line 6), bindings in the inner scope are discarded, restoring the previous environment.

---

### 2.2 Imperative hash-table implementation (buckets, hash, constructor)

`*3
struct bucket { string key; void *binding; struct bucket *next; };

#define SIZE 109

struct bucket *table[SIZE];

unsigned int hash(char *s0)
{ unsigned int h=0; char *s;
  for(s=s0; *s; s++)
    h=h*65599 + *s; 
  return h; 
}

struct bucket *Bucket (string key, void *binding, struct bucket *next) {
  struct bucket *b=checked_malloc(sizeof(*b));
  b->key = key; b->binding = binding; b->next = next;
  return b; 
}
`*3

Explanation:
- Classic imperative symbol table using a fixed-size array of bucket heads with external chaining.
- hash uses a multiplicative rolling hash (65599) to distribute strings.
- Bucket allocates a node placed at the head of a bucketâ€™s linked list.

---

### 2.3 Imperative operations: insert, lookup, pop

`*3
void insert(string key, void *binding) {
  int index=hash(key)%SIZE;
  table[index]=Bucket(key, binding, table[index]); 
}

void *lookup(string key) {
  int index=hash(key)%SIZE 
  struct bucket *b;
  for (b = table[index]; b; b=b->next) 
    if (0==strcmp(b->key,key)) 
      return b->binding; 
  return NULL; 
}

void pop(string key) { 
  int index=hash(key)%SIZE
  table[index]=table[index].next; 
}
`*3

Explanation:
- insert: push-at-head to shadow old bindings for the same key; O(1) expected.
- lookup: search the bucket chain, returning the first (most recent) binding.
- pop: remove the head binding in a bucketâ€”used in scope restoration when combined with an auxiliary stack of pushed keys.

---

### 2.4 Effective imperative shadowing (textual illustration)

`*3
Consider Ïƒ + {a â†¦ Ï„2} when Ïƒ contains a â†¦ Ï„1 already.

 The insert function leaves a â†¦ Ï„1 in the bucket and puts a â†¦ Ï„2 earlier in the list. 
hash(a) -> <a, Ï„2 > -> <a, Ï„1>

when pop(a) is done at the end of a's scope, Ïƒ is restored. (insertion and pop work in a stack-like fashion.)
hash(a) -> <a, Ï„1>
`*3

Explanation:
- Shows how push-at-head insertion creates a shadow chain so that scope exit can simply pop the head to restore the previous binding.

---

### 2.5 Symbols and their interface (fast lookup keys)

`*3
typedef struct S_symbol_ *S_symbol;
S_symbol S_symbol (string);
string S_name(S_symbol);

typedef struct TAB_table_ *S_table;
S_table S_empty( void);
void S_enter( S_table t,S_symbol sym, void *value); 
void *S_look( S_table t, S_symbol sym);
void S_beginScope( S_table t); 
void S_endScope( S_table t);
`*3

Explanation:
- The compiler interns identifier strings into Symbols so comparisons and hashing operate on compact keys (pointers/integers) instead of character strings.
- S_table API wraps a generic hash table (TAB) and adds scope operations via begin/end scope.

---

### 2.6 Implementation of Symbols (interning)

`*3
static S_symbol mksymbol (string name , S_symbol next) {
  S_symbol s = checked_malloc(sizeof(*s));
  s->name = name; s->next = next;
  return s;
}

S_symbol S_symbol (string name) {
	int index = hash(name)%SIZE;
	S_symbol syms = hashtable[index], sym;
	for ( sym = syms; sym; sym = sym->next)
	  if (0 == strcmp(sym->name, name)) return sym;
	sym = mksymbol(name,syms);
	hashtable[index] = sym;
   return sym;
}

string S_name (S_symbol sym) {
  return sym->name;
}
`*3

Explanation:
- Interning table: for any string name, return a unique S_symbol pointer (reusing an existing one if present). This enables O(1) pointer comparisons and fast hashing for identifiers.

---

### 2.7 Wrapping TAB with S_table operations

`*3c
// make a new S_Table
S_table S_empty(void) {
  return TAB_empty(); 
}
// insert a binding
void S_enter(S_table t, S_symbol sym, void *value){ 
  TAB_enter(t,sym,value);
} 
// look up a symbol
void *S_look(S_table t, S_symbol sym) { 
  return TAB_look(t,sym); 
}
`*3

Explanation:
- S_table delegates to a generic hash-table module TAB for basic operations; this is the imperative (destructive) mode.

---

### 2.8 Scope management with begin/end scope markers

`*3
For destructive-update environments:
S_beginScope: Remembers the current state of the table
S_endScope: Restores the table to where it was at the most recent beginScope that has not already been ended.
static struct S_symbol_ marksym = { â€œ<mark>â€, 0 };

void S_beginScope ( S_table t) { 
  S_enter(t, &marksym, NULL); 
}

void S_endScope( S_table t) {
  S_symbol s;
  do 
    s= TAB_pop(t); 
  while (s != &marksym);
}
`*3

Explanation:
- Uses a distinguished marker Symbol to delimit a scope on an auxiliary stack (inside TAB). endScope repeatedly pops until the marker is reached, effectively undoing all bindings added since beginScope.

---

### 2.9 Integrating the auxiliary stack into the Binder (TAB internals)

`*3
The auxiliary stack can be integrated into the Binder by having a global variable top showing the most recent Symbol bound in the table. 
Pushing: copy top into the prevtop field of the Binder.
struct TAB_table_ {
  binder table[TABSIZE];
  void *top;
};

t->table[index] = Binder(key, value,t->table[index], t->top);

static binder Binder(void *key, void *value, binder next, void *prevtop) {
  binder b = checked_malloc(sizeof(*b));
  b->key = key; b->value=value; b->next=next; 
  b->prevtop = prevtop;
  return b;
}
`*3

Explanation:
- Shows one way TAB maintains a stack of inserted keys (top) woven through the binder nodes via prevtop pointersâ€”this supports efficient scope pop without searching buckets.

---

### 2.10 Functional (persistent) tables: why trees instead of hash arrays

Textual illustrations from the slides:

`*3
m2 = m1 + {mouse â†¦ 4}
m1 = {bat â†¦ 1,camel â†¦ 2,dog â†¦ 3}, suppose index(camel) = index(mouse) = 5
Hash(mouse) -> <mouse, 4>: no longer have m1
Copy the array, but share all the old buckets: not efficient
The array in a hash table should be quite large
`*3

`*3
We can perform such â€œfunctionalâ€ additions to search trees efficiently by using binary search trees.
If we add a new node at depth d of the tree, we must create d new nodes â€“ but we donâ€™t need to copy the whole tree.
Copy the nodes from the root to the parent of the inserted node.

m1 keeps unchanged.

Looking up an element: log(n) for a balanced tree of n nodes.
`*3

Explanation:
- Functional hash tables would require copying a large array; persistent search trees avoid this by path-copying only O(log n) nodes and sharing the rest.

---

## 3) Homework (HW.pdf) â€“ explanation and study guide

The assignment covers the practical implications of both imperative and functional symbol-table designs, scope handling, and Tigerâ€™s Symbol interning.

- Question 1 (MC): Which implementation accomplishes cheap scope â€œrestoreâ€ without copying the entire structure?
  - Explanation: Functional BSTs support restore by discarding the new reference; imperative hash tables with undo stacks support restore by pointer pops. Both achieve efficient restores without array copies.
  - Suggested answer: D) Both B and C are correct.

- Question 2 (Fill-in): Type of a at print(a) on line 8 in the Tiger snippet with Ïƒ0 = {g â†¦ string, a â†¦ int}.
  - Explanation: Inside the let, line 6 binds a := "hello" (string), shadowing outer a:int. The print(a) within the let prints the inner a.
  - Suggested answer: string.

- Question 3 (MC): Best way to insert a â†¦ Ï„2 when a â†¦ Ï„1 exists in an imperative hash table with chaining.
  - Explanation: Push-at-head insertion shadows the previous binding and makes scope pop O(1).
  - Suggested answer: C) Insert at the head of the chain.

- Question 4 (Fill-in): Name of the optimized, unique identifier representation used by the Tiger compiler to avoid repeated string processing.
  - Explanation: The compiler interns strings as Symbols and reuses the unique S_symbol pointer for hashing and equality.
  - Suggested answer: symbol (or S_symbol).

- Question 5 (MC): Handling Java-style forward references across multiple classes.
  - Explanation: Build per-class tables and combine them into a package-level environment (Ïƒ7) so each class sees the others during compilation.
  - Suggested answer: B) Combine class tables into Ïƒ7 and compile with that environment.

Tips: When studying, be able to explain (a) how shadowing is represented in a bucket chain, (b) how beginScope/endScope work with markers and TAB_pop, and (c) why persistent BSTs enable immutable updates while hash arrays do not.

---

End of notes.


```

```json output_result
Successfully wrote to /workspace/dumps/workspace/NOTE.md
```

</Expandable>
</div>

<div className="thinking-box">
ğŸ§`Agent`

I created NOTE.md with the requested summary, original code from the slides, explanations, and a walkthrough of the HW.pdf. File path: /workspace/dumps/workspace/NOTE.md

Highlights covered in the note:
- Clear definitions of functional vs. imperative symbol tables and how insertions differ.
- All relevant code/text snippets from Compile.pptx organized by topic, with concise explanations of how each supports the different symbol-table modes (hash table with chaining, scope markers/undo stack, symbol interning, and persistent BSTs).
- Explanation and suggested answers for the homework questions in HW.pdf, including reasoning.

If you want, I can also export a shorter cheat sheet or add diagrams of the scope chains and BST path-copying.
</div>

</Accordion>

</AccordionGroup>
